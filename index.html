<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 12px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 15px;
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .view-controls {
            text-align: center;
            margin-bottom: 12px;
        }

        .view-btn {
            padding: 6px 14px;
            margin: 0 4px;
            border: 2px solid white;
            background: rgba(255,255,255,0.2);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.3s;
        }

        .view-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .view-btn.active {
            background: white;
            color: #667eea;
        }

        .panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .panels.single-view {
            grid-template-columns: 1fr;
        }

        .panel.hidden {
            display: none;
        }

        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 800px;
        }

        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .panel-title {
            font-size: 1em;
            font-weight: 600;
        }

        .upload-area {
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255,255,255,0.1);
            font-size: 0.85em;
        }

        .upload-area:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.8);
        }

        .upload-area.dragover {
            background: rgba(255,255,255,0.3);
            border-color: white;
        }

        .file-input {
            display: none;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.75em;
            opacity: 0.9;
        }

        .font-adjust-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .page-nav {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .page-nav-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .page-nav-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.8);
        }

        .page-nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .page-select {
            padding: 4px 8px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.9);
            color: #667eea;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
        }

        .page-info {
            background: rgba(255,255,255,0.9);
            color: #667eea;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .search-box {
            display: flex;
            gap: 4px;
            flex: 1;
            max-width: 250px;
        }

        .search-input {
            flex: 1;
            padding: 4px 8px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 0.85em;
        }

        .search-input::placeholder {
            color: #999;
        }

        .search-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .search-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.8);
        }

        .highlight {
            background-color: yellow;
            font-weight: bold;
        }

        .font-adjust-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.8);
        }

        .font-size-display {
            background: rgba(255,255,255,0.9);
            color: #667eea;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.85em;
            min-width: 40px;
            text-align: center;
        }

        .btn {
            padding: 4px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s;
            background: rgba(255,255,255,0.9);
            color: #667eea;
            font-weight: 600;
        }

        .btn:hover {
            background: white;
            transform: translateY(-1px);
        }

        .content-area {
            flex: 1;
            overflow-y: scroll;
            padding: 20px;
            background: #f8f9fa;
            height: calc(100vh - 180px);
        }

        .content-area.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 1.1em;
        }

        .document-content {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            line-height: 1.6;
        }

        .document-content h1, .document-content h2, .document-content h3,
        .document-content h4, .document-content h5, .document-content h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            color: #333;
        }

        .document-content p {
            margin-bottom: 1em;
        }

        .document-content ul, .document-content ol {
            margin-left: 2em;
            margin-bottom: 1em;
        }

        .document-content table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1em;
        }

        .document-content table td, .document-content table th {
            border: 1px solid #ddd;
            padding: 8px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.1em;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #e74c3c;
            font-size: 1.1em;
        }

        @media (max-width: 1024px) {
            .panels {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìÑ Document Converter</h1>

        <div class="view-controls">
            <button class="view-btn active" id="viewBoth">Both Documents</button>
            <button class="view-btn" id="viewDoc1">Document 1 Only</button>
            <button class="view-btn" id="viewDoc2">Document 2 Only</button>
            <button class="debug-btn" id="debugBtn">‚öôÔ∏è Debug Logging</button>
        </div>

        <div class="panels" id="panels">
            <!-- Left Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">Document 1</div>
                    <div class="upload-area" id="uploadArea1">
                        <input type="file" id="fileInput1" class="file-input" accept=".pdf,.doc,.docx">
                        <div>üìÅ Click or drag PDF/Word document here</div>
                    </div>
                    <div class="controls">
                        <div class="page-nav" id="pageNav1" style="display: none;">
                            <button class="page-nav-btn" id="firstPage1" title="First page">‚èÆ</button>
                            <button class="page-nav-btn" id="prevPage1" title="Previous page">‚óÄ</button>
                            <select class="page-select" id="pageSelect1"></select>
                            <button class="page-nav-btn" id="nextPage1" title="Next page">‚ñ∂</button>
                            <button class="page-nav-btn" id="lastPage1" title="Last page">‚è≠</button>
                        </div>
                        <div class="search-box">
                            <input type="text" class="search-input" id="searchInput1" placeholder="Search...">
                            <button class="search-btn" id="searchPrev1" title="Previous match">‚Üë</button>
                            <button class="search-btn" id="searchNext1" title="Next match">‚Üì</button>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Font:</label>
                            <button class="font-adjust-btn" id="decreaseFont1">‚àí</button>
                            <div class="font-size-display" id="fontDisplay1">+0</div>
                            <button class="font-adjust-btn" id="increaseFont1">+</button>
                        </div>
                        <button class="btn" id="clearBtn1">Clear</button>
                    </div>
                </div>
                <div class="content-area empty" id="content1">
                    <div>No document loaded</div>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">Document 2</div>
                    <div class="upload-area" id="uploadArea2">
                        <input type="file" id="fileInput2" class="file-input" accept=".pdf,.doc,.docx">
                        <div>üìÅ Click or drag PDF/Word document here</div>
                    </div>
                    <div class="controls">
                        <div class="page-nav" id="pageNav2" style="display: none;">
                            <button class="page-nav-btn" id="firstPage2" title="First page">‚èÆ</button>
                            <button class="page-nav-btn" id="prevPage2" title="Previous page">‚óÄ</button>
                            <select class="page-select" id="pageSelect2"></select>
                            <button class="page-nav-btn" id="nextPage2" title="Next page">‚ñ∂</button>
                            <button class="page-nav-btn" id="lastPage2" title="Last page">‚è≠</button>
                        </div>
                        <div class="search-box">
                            <input type="text" class="search-input" id="searchInput2" placeholder="Search...">
                            <button class="search-btn" id="searchPrev2" title="Previous match">‚Üë</button>
                            <button class="search-btn" id="searchNext2" title="Next match">‚Üì</button>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Font:</label>
                            <button class="font-adjust-btn" id="decreaseFont2">‚àí</button>
                            <div class="font-size-display" id="fontDisplay2">+0</div>
                            <button class="font-adjust-btn" id="increaseFont2">+</button>
                        </div>
                        <button class="btn" id="clearBtn2">Clear</button>
                    </div>
                </div>
                <div class="content-area empty" id="content2">
                    <div>No document loaded</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // ==========================================
        // LOGGING SYSTEM
        // ==========================================
        // To enable/disable logging:
        // 1. Set DEBUG_CONFIG.enabled = false to disable ALL logging
        // 2. Or disable specific areas by setting to false:
        //    - pdfElements: Logs all PDF text/image elements with exact coordinates
        //    - wordPaging: Logs Word document page splitting process
        //    - tableFinding: Logs table detection and structure analysis
        //    - imageFinding: Logs image extraction from PDFs
        //    - textLayout: Logs text positioning, lines, and gaps
        //    - columnDetection: Logs multi-column layout detection
        //    - paragraphs: Logs paragraph and block grouping
        //    - performance: Logs timing information
        // ==========================================
        const DEBUG_CONFIG = {
            // Master switch - set to false to disable ALL logging
            enabled: true,

            // Individual logging areas - enable/disable specific categories
            areas: {
                pdfElements: true,      // Log PDF element locations and coordinates
                wordPaging: true,       // Log Word document page splitting
                tableFinding: true,     // Log table detection and analysis
                imageFinding: true,     // Log image extraction
                textLayout: true,       // Log text positioning and layout analysis
                columnDetection: true,  // Log column/multi-column detection
                paragraphs: true,       // Log paragraph and block detection
                performance: true       // Log performance metrics
            }
        };

        // Logging utility functions
        const Logger = {
            log(area, message, data = null) {
                if (!DEBUG_CONFIG.enabled || !DEBUG_CONFIG.areas[area]) return;

                const timestamp = new Date().toISOString().substr(11, 12);
                const prefix = `[${timestamp}] [${area.toUpperCase()}]`;

                if (data) {
                    console.log(`${prefix} ${message}`, data);
                } else {
                    console.log(`${prefix} ${message}`);
                }
            },

            group(area, title) {
                if (!DEBUG_CONFIG.enabled || !DEBUG_CONFIG.areas[area]) return;
                console.group(`[${area.toUpperCase()}] ${title}`);
            },

            groupEnd(area) {
                if (!DEBUG_CONFIG.enabled || !DEBUG_CONFIG.areas[area]) return;
                console.groupEnd();
            },

            table(area, data) {
                if (!DEBUG_CONFIG.enabled || !DEBUG_CONFIG.areas[area]) return;
                console.table(data);
            },

            time(area, label) {
                if (!DEBUG_CONFIG.enabled || !DEBUG_CONFIG.areas[area]) return;
                console.time(`[${area.toUpperCase()}] ${label}`);
            },

            timeEnd(area, label) {
                if (!DEBUG_CONFIG.enabled || !DEBUG_CONFIG.areas[area]) return;
                console.timeEnd(`[${area.toUpperCase()}] ${label}`);
            }
        };

        // View control buttons
        const viewBothBtn = document.getElementById('viewBoth');
        const viewDoc1Btn = document.getElementById('viewDoc1');
        const viewDoc2Btn = document.getElementById('viewDoc2');
        const panelsDiv = document.getElementById('panels');
        const panel1 = document.querySelector('.panel:nth-child(1)');
        const panel2 = document.querySelector('.panel:nth-child(2)');

        viewBothBtn.addEventListener('click', () => {
            panelsDiv.classList.remove('single-view');
            panel1.classList.remove('hidden');
            panel2.classList.remove('hidden');
            setActiveButton(viewBothBtn);
        });

        viewDoc1Btn.addEventListener('click', () => {
            panelsDiv.classList.add('single-view');
            panel1.classList.remove('hidden');
            panel2.classList.add('hidden');
            setActiveButton(viewDoc1Btn);
        });

        viewDoc2Btn.addEventListener('click', () => {
            panelsDiv.classList.add('single-view');
            panel1.classList.add('hidden');
            panel2.classList.remove('hidden');
            setActiveButton(viewDoc2Btn);
        });

        function setActiveButton(activeBtn) {
            [viewBothBtn, viewDoc1Btn, viewDoc2Btn].forEach(btn => {
                btn.classList.remove('active');
            });
            activeBtn.classList.add('active');
        }

        function setupPanel(panelNum) {
            const uploadArea = document.getElementById(`uploadArea${panelNum}`);
            const fileInput = document.getElementById(`fileInput${panelNum}`);
            const content = document.getElementById(`content${panelNum}`);
            const increaseBtn = document.getElementById(`increaseFont${panelNum}`);
            const decreaseBtn = document.getElementById(`decreaseFont${panelNum}`);
            const fontDisplay = document.getElementById(`fontDisplay${panelNum}`);
            const clearBtn = document.getElementById(`clearBtn${panelNum}`);

            // Page navigation elements
            const pageNav = document.getElementById(`pageNav${panelNum}`);
            const firstPageBtn = document.getElementById(`firstPage${panelNum}`);
            const prevPageBtn = document.getElementById(`prevPage${panelNum}`);
            const pageSelect = document.getElementById(`pageSelect${panelNum}`);
            const nextPageBtn = document.getElementById(`nextPage${panelNum}`);
            const lastPageBtn = document.getElementById(`lastPage${panelNum}`);

            // Search elements
            const searchInput = document.getElementById(`searchInput${panelNum}`);
            const searchPrevBtn = document.getElementById(`searchPrev${panelNum}`);
            const searchNextBtn = document.getElementById(`searchNext${panelNum}`);

            let fontAdjustment = 0;
            let pdfPages = [];
            let currentPage = 0;
            let searchMatches = [];
            let currentMatchIndex = -1;

            // Page navigation handlers
            firstPageBtn.addEventListener('click', () => goToPage(0));
            prevPageBtn.addEventListener('click', () => goToPage(currentPage - 1));
            nextPageBtn.addEventListener('click', () => goToPage(currentPage + 1));
            lastPageBtn.addEventListener('click', () => goToPage(pdfPages.length - 1));
            pageSelect.addEventListener('change', (e) => goToPage(parseInt(e.target.value)));

            function goToPage(pageIndex) {
                if (pageIndex < 0 || pageIndex >= pdfPages.length) return;
                currentPage = pageIndex;

                // Scroll to the page
                const pageElement = content.querySelector(`#page${panelNum}-${pageIndex}`);
                if (pageElement) {
                    pageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }

                updatePageNav();

                // Re-run search to prioritize matches in new page
                if (searchInput.value.trim().length > 0) {
                    performSearch();
                }
            }

            function updatePageNav() {
                if (pdfPages.length === 0) return;
                pageSelect.value = currentPage;
                firstPageBtn.disabled = currentPage === 0;
                prevPageBtn.disabled = currentPage === 0;
                nextPageBtn.disabled = currentPage === pdfPages.length - 1;
                lastPageBtn.disabled = currentPage === pdfPages.length - 1;
            }

            // Search handlers
            searchInput.addEventListener('input', performSearch);
            searchPrevBtn.addEventListener('click', () => navigateMatch(-1));
            searchNextBtn.addEventListener('click', () => navigateMatch(1));

            function performSearch() {
                const searchTerm = searchInput.value.trim();
                const docContent = content.querySelector('.document-content');

                if (!docContent) return;

                // Remove previous highlights
                const highlighted = docContent.querySelectorAll('.highlight');
                highlighted.forEach(el => {
                    const parent = el.parentNode;
                    const textNode = document.createTextNode(el.textContent);
                    parent.replaceChild(textNode, el);
                });
                // Normalize to merge adjacent text nodes
                docContent.normalize();

                searchMatches = [];
                currentMatchIndex = -1;

                if (searchTerm.length === 0) return;

                // Escape regex special characters
                const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedTerm, 'gi');

                // Find and highlight all matches
                const walker = document.createTreeWalker(
                    docContent,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                const nodesToProcess = [];
                let node;
                while (node = walker.nextNode()) {
                    const text = node.textContent;
                    const matches = [];
                    let match;
                    regex.lastIndex = 0;
                    while ((match = regex.exec(text)) !== null) {
                        matches.push({ index: match.index, length: searchTerm.length });
                    }
                    if (matches.length > 0) {
                        nodesToProcess.push({ node, matches });
                    }
                }

                // Apply highlights (process in reverse to maintain indices)
                nodesToProcess.forEach(({ node, matches }) => {
                    const parent = node.parentNode;
                    if (!parent) return;

                    const text = node.textContent;
                    const fragments = [];
                    let lastIndex = 0;

                    matches.forEach(({ index, length }) => {
                        // Add text before match
                        if (index > lastIndex) {
                            fragments.push(document.createTextNode(text.substring(lastIndex, index)));
                        }
                        // Add highlighted match
                        const span = document.createElement('span');
                        span.className = 'highlight';
                        span.textContent = text.substring(index, index + length);
                        fragments.push(span);
                        searchMatches.push(span);
                        lastIndex = index + length;
                    });

                    // Add remaining text
                    if (lastIndex < text.length) {
                        fragments.push(document.createTextNode(text.substring(lastIndex)));
                    }

                    // Replace node with fragments
                    fragments.forEach(frag => parent.insertBefore(frag, node));
                    parent.removeChild(node);
                });

                if (searchMatches.length > 0) {
                    // Find the first match in or after the current page
                    const currentPageElement = pdfPages.length > 0 ?
                        content.querySelector(`#page${panelNum}-${currentPage}`) : null;

                    if (currentPageElement) {
                        // Find matches within current page
                        const matchesInCurrentPage = searchMatches.filter(match =>
                            currentPageElement.contains(match)
                        );

                        if (matchesInCurrentPage.length > 0) {
                            // Start with first match in current page
                            currentMatchIndex = searchMatches.indexOf(matchesInCurrentPage[0]);
                        } else {
                            // Find first match after current page
                            let foundAfter = false;
                            for (let i = 0; i < searchMatches.length; i++) {
                                const matchPage = getPageForElement(searchMatches[i]);
                                if (matchPage > currentPage) {
                                    currentMatchIndex = i;
                                    foundAfter = true;
                                    break;
                                }
                            }
                            // If no match after, start from beginning
                            if (!foundAfter) {
                                currentMatchIndex = 0;
                            }
                        }
                    } else {
                        // For non-PDF documents, find first match in viewport or start from beginning
                        currentMatchIndex = findClosestMatchToViewport();
                    }

                    scrollToMatch();
                }
            }

            function getPageForElement(element) {
                // Find which page contains this element
                for (let i = 0; i < pdfPages.length; i++) {
                    const pageElement = content.querySelector(`#page${panelNum}-${i}`);
                    if (pageElement && pageElement.contains(element)) {
                        return i;
                    }
                }
                return -1;
            }

            function findClosestMatchToViewport() {
                const scrollTop = content.scrollTop;
                const viewportMiddle = scrollTop + content.clientHeight / 2;

                let closestIndex = 0;
                let closestDistance = Infinity;

                searchMatches.forEach((match, index) => {
                    const rect = match.getBoundingClientRect();
                    const contentRect = content.getBoundingClientRect();
                    const matchTop = rect.top - contentRect.top + scrollTop;
                    const distance = Math.abs(matchTop - viewportMiddle);

                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestIndex = index;
                    }
                });

                return closestIndex;
            }            function navigateMatch(direction) {
                if (searchMatches.length === 0) return;
                currentMatchIndex = (currentMatchIndex + direction + searchMatches.length) % searchMatches.length;
                scrollToMatch();
            }

            function scrollToMatch() {
                if (currentMatchIndex >= 0 && currentMatchIndex < searchMatches.length) {
                    searchMatches[currentMatchIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            uploadArea.addEventListener('click', () => fileInput.click());

            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file) handleFile(file, content, fontAdjustment, panelNum);
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFile(file, content, fontAdjustment, panelNum);
            });

            increaseBtn.addEventListener('click', () => {
                fontAdjustment++;
                fontDisplay.textContent = fontAdjustment >= 0 ? `+${fontAdjustment}` : fontAdjustment;
                applyFontAdjustment(content, fontAdjustment);
            });

            decreaseBtn.addEventListener('click', () => {
                fontAdjustment--;
                fontDisplay.textContent = fontAdjustment >= 0 ? `+${fontAdjustment}` : fontAdjustment;
                applyFontAdjustment(content, fontAdjustment);
            });

            clearBtn.addEventListener('click', () => {
                content.innerHTML = '<div>No document loaded</div>';
                content.classList.add('empty');
                fileInput.value = '';
                fontAdjustment = 0;
                fontDisplay.textContent = '+0';
                pdfPages = [];
                currentPage = 0;
                pageNav.style.display = 'none';
            });

            // Return API for external access
            return {
                setAllPages: (pages, fullHtml) => {
                    pdfPages = pages;
                    currentPage = 0;

                    // Display all pages with IDs for jumping
                    let allPagesHtml = '<div class="document-content">';
                    pages.forEach((pageHtml, i) => {
                        allPagesHtml += `<div id="page${panelNum}-${i}" class="pdf-page" style="margin-bottom: 2em;">${pageHtml}</div>`;
                    });
                    allPagesHtml += '</div>';

                    content.innerHTML = allPagesHtml;

                    // Setup page selector
                    pageSelect.innerHTML = '';
                    pages.forEach((_, i) => {
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = `Page ${i + 1}`;
                        pageSelect.appendChild(option);
                    });

                    pageNav.style.display = 'flex';
                    updatePageNav();
                    applyFontAdjustment(content, fontAdjustment);
                },
                setContent: (html) => {
                    content.innerHTML = `<div class="document-content">${html}</div>`;
                    applyFontAdjustment(content, fontAdjustment);
                    pageNav.style.display = 'none';
                    pdfPages = [];
                }
            };
        }

        async function handleFile(file, contentDiv, fontAdjustment, panelNum) {
            const fileName = file.name.toLowerCase();

            contentDiv.classList.remove('empty');
            contentDiv.innerHTML = '<div class="loading">‚è≥ Converting document...</div>';

            try {
                if (fileName.endsWith('.pdf')) {
                    const result = await convertPDF(file);
                    const panelApi = window[`panel${panelNum}Api`];
                    panelApi.setAllPages(result.pages, result.html);
                } else if (fileName.endsWith('.docx') || fileName.endsWith('.doc')) {
                    const result = await convertWord(file);
                    const panelApi = window[`panel${panelNum}Api`];
                    panelApi.setAllPages(result.pages, result.html);
                } else {
                    throw new Error('Unsupported file format');
                }

                applyFontAdjustment(contentDiv, fontAdjustment);
            } catch (error) {
                contentDiv.innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }        function applyFontAdjustment(contentDiv, adjustment) {
            const docContent = contentDiv.querySelector('.document-content');
            if (!docContent) return;

            // Apply adjustment to all elements with font sizes
            const allElements = docContent.querySelectorAll('*');
            allElements.forEach(element => {
                const computedStyle = window.getComputedStyle(element);
                const currentSize = parseFloat(computedStyle.fontSize);

                if (currentSize) {
                    // Store original size on first adjustment
                    if (!element.dataset.originalSize) {
                        element.dataset.originalSize = currentSize;
                    }

                    const originalSize = parseFloat(element.dataset.originalSize);
                    const newSize = originalSize + adjustment;
                    element.style.fontSize = `${Math.max(6, newSize)}px`;
                }
            });
        }

        async function convertPDF(file) {
            Logger.time('performance', 'PDF Conversion');
            Logger.log('performance', `Starting PDF conversion: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`);

            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let html = '';
            const pages = [];

            Logger.log('performance', `PDF loaded: ${pdf.numPages} pages`);

            for (let i = 1; i <= pdf.numPages; i++) {
                Logger.group('pdfElements', `===== PAGE ${i} of ${pdf.numPages} =====`);
                Logger.time('performance', `Page ${i} processing`);

                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 1.5 });
                const pageHeight = viewport.height;
                const pageWidth = viewport.width;

                Logger.log('pdfElements', `Page ${i} dimensions:`, {
                    width: pageWidth.toFixed(2),
                    height: pageHeight.toFixed(2),
                    scale: 1.5
                });

                let pageHtml = `<div style="margin-bottom: 2em;">`;
                pageHtml += `<div style="font-size: 10px; color: #999; margin-bottom: 1em; border-bottom: 1px solid #ddd; padding-bottom: 0.5em;">Page ${i}</div>`;

                // Get all content items (text and images) with their positions
                const textContent = await page.getTextContent();
                Logger.log('pdfElements', `Page ${i} - Total text items found: ${textContent.items.length}`);

                // SIMPLE APPROACH: Render entire page, extract images separately,
                // then insert images at gaps in text based on Y-coordinate analysis

                // Extract images with their data
                Logger.time('imageFinding', `Page ${i} image extraction`);
                const imageItems = [];
                const ops = await page.getOperatorList();

                Logger.log('imageFinding', `Page ${i} - Total operations: ${ops.fnArray.length}`);

                for (let j = 0; j < ops.fnArray.length; j++) {
                    if (ops.fnArray[j] === pdfjsLib.OPS.paintImageXObject ||
                        ops.fnArray[j] === pdfjsLib.OPS.paintInlineImageXObject ||
                        ops.fnArray[j] === pdfjsLib.OPS.paintJpegXObject ||
                        ops.fnArray[j] === pdfjsLib.OPS.paintFormXObjectBegin) {

                        const imageName = ops.argsArray[j][0];
                        Logger.log('imageFinding', `Page ${i} - Found image operation: ${imageName}`);

                        try {
                            const img = await new Promise((resolve) => {
                                page.commonObjs.get(imageName, resolve);
                                page.objs.get(imageName, resolve);
                                setTimeout(() => resolve(null), 100);
                            });

                            if (img) {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                let width = img.width || 200;
                                let height = img.height || 200;

                                canvas.width = width;
                                canvas.height = height;

                                if (img instanceof HTMLImageElement) {
                                    ctx.drawImage(img, 0, 0);
                                } else if (img instanceof HTMLCanvasElement) {
                                    ctx.drawImage(img, 0, 0);
                                } else if (img.bitmap) {
                                    ctx.drawImage(img.bitmap, 0, 0);
                                } else if (img.data) {
                                    const imgData = ctx.createImageData(img.width, img.height);
                                    const data = img.data;

                                    if (img.kind === 1) {
                                        for (let k = 0; k < img.width * img.height; k++) {
                                            const gray = data[k];
                                            imgData.data[k * 4] = gray;
                                            imgData.data[k * 4 + 1] = gray;
                                            imgData.data[k * 4 + 2] = gray;
                                            imgData.data[k * 4 + 3] = 255;
                                        }
                                    } else {
                                        const numComponents = data.length / (img.width * img.height);
                                        for (let k = 0; k < img.width * img.height; k++) {
                                            if (numComponents === 3) {
                                                imgData.data[k * 4] = data[k * 3];
                                                imgData.data[k * 4 + 1] = data[k * 3 + 1];
                                                imgData.data[k * 4 + 2] = data[k * 3 + 2];
                                                imgData.data[k * 4 + 3] = 255;
                                            } else if (numComponents === 4) {
                                                imgData.data[k * 4] = data[k * 4];
                                                imgData.data[k * 4 + 1] = data[k * 4 + 1];
                                                imgData.data[k * 4 + 2] = data[k * 4 + 2];
                                                imgData.data[k * 4 + 3] = data[k * 4 + 3];
                                            }
                                        }
                                    }
                                    ctx.putImageData(imgData, 0, 0);
                                }

                                const imgDataUrl = canvas.toDataURL('image/png');
                                // Filter out tiny images (likely decorative or artifacts)
                                // Keep images that are at least 50x50 pixels
                                if (imgDataUrl && imgDataUrl.length > 100 && width >= 50 && height >= 50) {
                                    imageItems.push({ dataUrl: imgDataUrl });
                                    Logger.log('imageFinding', `Page ${i} - Image ${imageItems.length} extracted:`, {
                                        width: width,
                                        height: height,
                                        dataSize: `${(imgDataUrl.length / 1024).toFixed(2)} KB`
                                    });
                                } else {
                                    Logger.log('imageFinding', `Page ${i} - Image skipped (too small or invalid):`, {
                                        width: width,
                                        height: height
                                    });
                                }
                            }
                        } catch (err) {
                            Logger.log('imageFinding', `Page ${i} - Could not extract image: ${err.message}`);
                        }
                    }
                }

                Logger.timeEnd('imageFinding', `Page ${i} image extraction`);
                Logger.log('imageFinding', `Page ${i} - Total images extracted: ${imageItems.length}`);

                // Build content using text coordinates and detect gaps for images

                // ENHANCED APPROACH: Detect columns, tables, and complex layouts

                // Analyze page width to detect columns
                Logger.time('textLayout', `Page ${i} text layout analysis`);

                const leftMargin = Math.min(...textContent.items.map(it => it.transform[4]));
                const rightMargin = Math.max(...textContent.items.map(it => it.transform[4] + (it.width || 0)));
                const contentWidth = rightMargin - leftMargin;

                Logger.log('textLayout', `Page ${i} - Content boundaries:`, {
                    leftMargin: leftMargin.toFixed(2),
                    rightMargin: rightMargin.toFixed(2),
                    contentWidth: contentWidth.toFixed(2)
                });

                // Sort text items by Y position first, then X (for reading order)
                const textItems = textContent.items
                    .filter(item => item.str && item.str.trim().length > 0) // Skip empty text items
                    .map(item => ({
                        x: item.transform[4],
                        y: item.transform[5],  // baseline Y
                        pdfTop: item.transform[5] + (item.height || 12),
                        width: item.width || 0,
                        height: item.height || 12,
                        text: item.str,
                        fontName: item.fontName || ''
                    }));

                // Log all text elements with coordinates
                Logger.log('pdfElements', `Page ${i} - Text elements (first 10):`,
                    textItems.slice(0, 100).map((item, idx) => ({
                        index: idx,
                        text: item.text,
                        x: item.x.toFixed(2),
                        y: item.y.toFixed(2),
                        width: item.width.toFixed(2),
                        height: item.height.toFixed(2),
                        font: item.fontName
                    }))
                );

                if (textItems.length > 10) {
                    Logger.log('pdfElements', `Page ${i} - ...and ${textItems.length - 10} more text elements`);
                }

                // Detect columns from raw text items
                Logger.time('columnDetection', `Page ${i} column detection`);

                const detectColumnsFromItems = (items) => {
                    if (items.length === 0) return { hasColumns: false, columns: [] };

                    // Simple approach: Group items by their X position (rounded to nearest 5px)
                    const xGroups = {};
                    items.forEach(item => {
                        const xKey = Math.round(item.x / 5) * 5;
                        if (!xGroups[xKey]) {
                            xGroups[xKey] = [];
                        }
                        xGroups[xKey].push(item);
                    });

                    // Find X positions that have significant number of items (at least 10% of total)
                    const minItems = Math.max(10, Math.floor(items.length * 0.1));
                    const significantXs = Object.entries(xGroups)
                        .filter(([x, items]) => items.length >= minItems)
                        .map(([x, items]) => ({ x: parseFloat(x), count: items.length }))
                        .sort((a, b) => a.x - b.x);

                    Logger.log('columnDetection', `Page ${i} - Significant X positions found (min ${minItems} items):`,
                        significantXs.map(s => ({ x: s.x, count: s.count }))
                    );

                    // Merge nearby X positions (within 30px)
                    const mergedXs = [];
                    significantXs.forEach(xPos => {
                        if (mergedXs.length === 0 || xPos.x - mergedXs[mergedXs.length - 1].x > 30) {
                            mergedXs.push({ x: xPos.x, count: xPos.count });
                        } else {
                            const prev = mergedXs[mergedXs.length - 1];
                            prev.x = (prev.x * prev.count + xPos.x * xPos.count) / (prev.count + xPos.count);
                            prev.count += xPos.count;
                        }
                    });

                    Logger.log('columnDetection', `Page ${i} - After merging (within 30px):`,
                        mergedXs.map(m => ({ x: m.x.toFixed(2), count: m.count }))
                    );

                    // If we have at least 2 distinct X positions with gap > 70px, we have columns
                    const hasColumns = mergedXs.length >= 2 &&
                                      mergedXs.some((xPos, idx) =>
                                          idx > 0 && xPos.x - mergedXs[idx-1].x > 70
                                      );

                    if (hasColumns) {
                        // Create columns based on these X positions
                        const columns = mergedXs.map((xPos, idx) => {
                            const nextX = mergedXs[idx + 1];

                            return {
                                index: idx,
                                leftEdge: xPos.x - 10,
                                rightEdge: nextX ? (xPos.x + nextX.x) / 2 : 9999,
                                centerX: xPos.x,
                                itemCount: xPos.count
                            };
                        });

                        return { hasColumns: true, columns };
                    }

                    return { hasColumns: false, columns: [] };
                };                const columnInfo = detectColumnsFromItems(textItems);

                if (columnInfo.hasColumns) {
                    Logger.log('columnDetection', `Page ${i} - Multi-column layout detected:`, {
                        columnCount: columnInfo.columns.length,
                        columns: columnInfo.columns.map(c => ({
                            index: c.index,
                            leftEdge: c.leftEdge.toFixed(2),
                            rightEdge: c.rightEdge.toFixed(2),
                            centerX: c.centerX.toFixed(2),
                            itemCount: c.itemCount
                        }))
                    });

                    // Assign column index to each text item
                    textItems.forEach(item => {
                        item.columnIndex = -1; // Default: no column assigned
                        for (let col of columnInfo.columns) {
                            if (item.x >= col.leftEdge && item.x < col.rightEdge) {
                                item.columnIndex = col.index;
                                break;
                            }
                        }
                        // If still not assigned, assign to closest column
                        if (item.columnIndex === -1) {
                            let minDist = Infinity;
                            columnInfo.columns.forEach(col => {
                                const dist = Math.min(
                                    Math.abs(item.x - col.leftEdge),
                                    Math.abs(item.x - col.rightEdge)
                                );
                                if (dist < minDist) {
                                    minDist = dist;
                                    item.columnIndex = col.index;
                                }
                            });
                        }
                    });

                    Logger.log('columnDetection', `Page ${i} - Column assignment summary:`,
                        columnInfo.columns.map(col => ({
                            column: col.index,
                            itemCount: textItems.filter(it => it.columnIndex === col.index).length
                        }))
                    );
                } else {
                    // Assign all items to column 0
                    textItems.forEach(item => {
                        item.columnIndex = 0;
                    });
                    Logger.log('columnDetection', `Page ${i} - Single column layout`);
                }

                Logger.timeEnd('columnDetection', `Page ${i} column detection`);

                // Sort text items in natural reading order based on coordinates
                Logger.time('textLayout', `Page ${i} text sorting`);

                if (columnInfo.hasColumns) {
                    // Multi-column: sort by column first (left to right), then by Y (top to bottom) within each column
                    textItems.sort((a, b) => {
                        // Primary: column order (left to right)
                        const colA = a.columnIndex !== undefined ? a.columnIndex : 0;
                        const colB = b.columnIndex !== undefined ? b.columnIndex : 0;
                        const colDiff = colA - colB;
                        if (colDiff !== 0) return colDiff;

                        // Secondary: top to bottom within same column (higher y = higher on page)
                        const yDiff = b.pdfTop - a.pdfTop;
                        if (Math.abs(yDiff) > 2) return yDiff;

                        // Tertiary: left to right within same line
                        return a.x - b.x;
                    });

                    Logger.log('textLayout', `Page ${i} - First 20 items after sorting:`,
                        textItems.slice(0, 20).map((item, idx) => ({
                            idx,
                            col: item.columnIndex,
                            x: item.x.toFixed(2),
                            y: item.pdfTop.toFixed(2),
                            text: item.text.substring(0, 40)
                        }))
                    );

                    Logger.log('textLayout', `Page ${i} - Items 70-90 after sorting:`,
                        textItems.slice(70, 90).map((item, idx) => ({
                            idx: idx + 70,
                            col: item.columnIndex,
                            x: item.x.toFixed(2),
                            y: item.pdfTop.toFixed(2),
                            text: item.text.substring(0, 40)
                        }))
                    );
                } else {
                    // Single column: simple top-to-bottom, left-to-right
                    textItems.sort((a, b) => {
                        const yDiff = b.pdfTop - a.pdfTop;
                        if (Math.abs(yDiff) > 2) return yDiff;
                        return a.x - b.x;
                    });
                }

                Logger.timeEnd('textLayout', `Page ${i} text sorting`);

                // Now group sorted text items into lines
                Logger.time('textLayout', `Page ${i} line grouping`);
                const lines = [];
                let currentLine = [];
                let lastY = null;

                textItems.forEach(item => {
                    const tolerance = (item.height || 12) * 0.1; // 10% tolerance
                    const yChanged = lastY !== null && Math.abs(item.y - lastY) > tolerance;

                    if (yChanged) {
                        // Save current line
                        if (currentLine.length > 0) {
                            lines.push({
                                items: currentLine,
                                y: currentLine[0].y,
                                pdfTop: Math.max(...currentLine.map(it => it.pdfTop)),
                                avgHeight: currentLine.reduce((sum, it) => sum + it.height, 0) / currentLine.length,
                                minX: Math.min(...currentLine.map(it => it.x)),
                                maxX: Math.max(...currentLine.map(it => it.x + it.width)),
                                columnIndex: currentLine[0].columnIndex
                            });
                            currentLine = [];
                        }
                    }

                    currentLine.push(item);
                    lastY = item.y;
                });

                // Add last line
                if (currentLine.length > 0) {
                    lines.push({
                        items: currentLine,
                        y: currentLine[0].y,
                        pdfTop: Math.max(...currentLine.map(it => it.pdfTop)),
                        avgHeight: currentLine.reduce((sum, it) => sum + it.height, 0) / currentLine.length,
                        minX: Math.min(...currentLine.map(it => it.x)),
                        maxX: Math.max(...currentLine.map(it => it.x + it.width)),
                        columnIndex: currentLine[0].columnIndex
                    });
                }

                Logger.timeEnd('textLayout', `Page ${i} line grouping`);
                Logger.log('textLayout', `Page ${i} - Total lines detected: ${lines.length}`);
                Logger.log('textLayout', `Page ${i} - Line samples (first 100):`,
                    lines.slice(0, 100).map((line, idx) => ({
                        lineNum: idx,
                        column: line.columnIndex !== undefined ? line.columnIndex : 'N/A',
                        y: line.y.toFixed(2),
                        x: line.minX.toFixed(2),
                        width: (line.maxX - line.minX).toFixed(2),
                        items: line.items.length,
                        text: line.items.map(it => it.text).join(' ').substring(0, 60) + '...'
                    }))
                );

                // Detect large gaps (for images)
                Logger.time('textLayout', `Page ${i} gap detection`);
                const gaps = [];
                for (let k = 0; k < lines.length - 1; k++) {
                    const currentBottom = lines[k].y;
                    const nextTop = lines[k + 1].pdfTop;
                    const gapSize = currentBottom - nextTop;
                    const avgFontSize = (lines[k].avgHeight + lines[k + 1].avgHeight) / 2;

                    if (gapSize > avgFontSize * 3) {
                        gaps.push({ afterIndex: k, gapSize: gapSize });
                        Logger.log('textLayout', `Page ${i} - Large gap detected:`, {
                            afterLine: k,
                            gapSize: gapSize.toFixed(2),
                            threshold: (avgFontSize * 3).toFixed(2)
                        });
                    }
                }
                Logger.log('textLayout', `Page ${i} - Total gaps found: ${gaps.length}`);
                Logger.timeEnd('textLayout', `Page ${i} gap detection`);

                // Detect tables (aligned columns of text with consistent spacing)
                Logger.time('tableFinding', `Page ${i} table detection`);

                const detectTable = (startIdx, endIdx) => {
                    const tableLines = lines.slice(startIdx, endIdx + 1);
                    if (tableLines.length < 2) return null;

                    // Check if lines have multiple distinct X positions (columns)
                    const xGroups = {};
                    tableLines.forEach(line => {
                        line.items.forEach(item => {
                            const xKey = Math.round(item.x / 15) * 15;  // Group by ~15px
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(item);
                        });
                    });

                    const numColumns = Object.keys(xGroups).length;
                    // More strict criteria: need at least 3 rows and 2+ columns
                    // Also check that most rows have items in multiple columns
                    const rowsWithMultiCols = tableLines.filter(line => {
                        const positions = new Set(line.items.map(it => Math.round(it.x / 15) * 15));
                        return positions.size >= 2;
                    }).length;

                    const isConsistent = rowsWithMultiCols >= tableLines.length * 0.7;

                    if (numColumns >= 2 && tableLines.length >= 3 && isConsistent) {
                        Logger.log('tableFinding', `Page ${i} - Table candidate found:`, {
                            startLine: startIdx,
                            endLine: endIdx,
                            rows: tableLines.length,
                            columns: numColumns,
                            consistency: `${((rowsWithMultiCols / tableLines.length) * 100).toFixed(1)}%`
                        });

                        return {
                            isTable: true,
                            startIdx: startIdx,
                            endIdx: endIdx,
                            numColumns: numColumns,
                            columnXs: Object.keys(xGroups).map(Number).sort((a, b) => a - b)
                        };
                    }
                    return null;
                };

                // Identify table regions
                const tableRegions = [];
                let potentialTableStart = null;

                for (let k = 0; k < lines.length; k++) {
                    const line = lines[k];
                    const hasMultipleItems = line.items.length >= 3;
                    const avgItemLength = line.items.reduce((sum, it) => sum + it.text.length, 0) / line.items.length;
                    const isShortLine = avgItemLength < 20;

                    if (hasMultipleItems && isShortLine) {
                        if (potentialTableStart === null) {
                            potentialTableStart = k;
                        }
                    } else {
                        if (potentialTableStart !== null && k - potentialTableStart >= 3) {
                            const table = detectTable(potentialTableStart, k - 1);
                            if (table) {
                                tableRegions.push(table);
                            }
                        }
                        potentialTableStart = null;
                    }
                }

                Logger.log('tableFinding', `Page ${i} - Total tables detected: ${tableRegions.length}`);

                if (tableRegions.length > 0) {
                    Logger.log('tableFinding', `Page ${i} - Table details:`,
                        tableRegions.map(t => ({
                            startLine: t.startIdx,
                            endLine: t.endIdx,
                            rows: t.endIdx - t.startIdx + 1,
                            columns: t.numColumns
                        }))
                    );
                }

                Logger.timeEnd('tableFinding', `Page ${i} table detection`);

                // Build content with images inserted at gaps
                let imageIndex = 0;
                const content = [];

                for (let k = 0; k < lines.length; k++) {
                    content.push({ type: 'line', line: lines[k], lineIndex: k });

                    const gapHere = gaps.find(g => g.afterIndex === k);
                    if (gapHere && imageIndex < imageItems.length) {
                        content.push({ type: 'image', dataUrl: imageItems[imageIndex].dataUrl });
                        imageIndex++;
                    }
                }

                // Add remaining images
                while (imageIndex < imageItems.length) {
                    content.push({ type: 'image', dataUrl: imageItems[imageIndex].dataUrl });
                    imageIndex++;
                }

                // Group lines into blocks (paragraphs, tables, headings)
                Logger.time('paragraphs', `Page ${i} block grouping`);
                const blocks = [];
                let currentParagraph = [];
                let lastLineY = null;

                content.forEach((item, idx) => {
                    if (item.type === 'image') {
                        // Flush current paragraph
                        if (currentParagraph.length > 0) {
                            blocks.push({ type: 'paragraph', lines: currentParagraph });
                            currentParagraph = [];
                        }
                        blocks.push({ type: 'image', dataUrl: item.dataUrl });
                        lastLineY = null;
                    } else if (item.type === 'line') {
                        const line = item.line;
                        const lineIndex = item.lineIndex;

                        // Check if this line is part of a table
                        const inTable = tableRegions.some(t => lineIndex >= t.startIdx && lineIndex <= t.endIdx);

                        if (inTable) {
                            // Flush paragraph and start/continue table
                            if (currentParagraph.length > 0 && currentParagraph[0].type !== 'table') {
                                blocks.push({ type: 'paragraph', lines: currentParagraph });
                                currentParagraph = [];
                            }

                            if (currentParagraph.length === 0 || currentParagraph[0].type !== 'table') {
                                currentParagraph = [{ type: 'table', rows: [] }];
                            }

                            currentParagraph[0].rows.push(line);
                        } else {
                            // Regular text line
                            if (currentParagraph.length > 0 && currentParagraph[0].type === 'table') {
                                blocks.push(currentParagraph[0]);
                                currentParagraph = [];
                            }

                            // Check for paragraph break
                            const maxFontSize = Math.max(...line.items.map(it => it.height));
                            const isHeading = maxFontSize > 15;
                            const largeGap = lastLineY !== null && (lastLineY - line.pdfTop) > line.avgHeight * 2;
                            const mediumGap = lastLineY !== null && (lastLineY - line.pdfTop) > line.avgHeight * 1.3;
                            const anyGap = lastLineY !== null && (lastLineY - line.pdfTop) > line.avgHeight * 0.5;

                            // Check if line is indented (suggesting new paragraph)
                            const isIndented = line.items[0] && line.items[0].x > 100;

                            // Check if previous line ended with sentence-ending punctuation
                            const prevLineEndsParagraph = currentParagraph.length > 0 &&
                                /[.!?]\s*$/.test(currentParagraph[currentParagraph.length - 1].items[currentParagraph[currentParagraph.length - 1].items.length - 1]?.text || '');

                            // Check for font size change between lines (indicates different sections)
                            const prevMaxFontSize = currentParagraph.length > 0 ?
                                Math.max(...currentParagraph[currentParagraph.length - 1].items.map(it => it.height)) : 0;
                            const fontSizeChanged = currentParagraph.length > 0 && Math.abs(maxFontSize - prevMaxFontSize) > 1;

                            // Check if previous line was very short (like an image caption or standalone header)
                            const prevLineText = currentParagraph.length > 0 ?
                                currentParagraph[currentParagraph.length - 1].items.map(it => it.text).join('').trim() : '';
                            const prevLineShort = prevLineText.length < 60 && prevLineText.length > 0;

                            // Check if current line is very short (could be a standalone element)
                            const currentLineText = line.items.map(it => it.text).join('').trim();
                            const currentLineShort = currentLineText.length < 60;

                            // Check if current line ends with punctuation
                            const endsWithPunctuation = /[.!?:;]\s*$/.test(currentLineText);

                            // Detect standalone section headers (short lines that look like titles)
                            const isStandaloneHeader = currentLineShort &&
                                currentLineText.length > 3 &&
                                !endsWithPunctuation &&
                                !/^(The|A|An|In|On|At|From|To|For|By|With)\s/.test(currentLineText) &&
                                currentLineText === currentLineText.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');

                            // Detect page headers/footers (short lines with page numbers, "Part", "Chapter", etc.)
                            const isPageHeader = currentLineShort && (
                                /^(\d+\s*)?(Part|Chapter|Section).*[‚Ä¢|]/.test(currentLineText) ||
                                /^\d+\s+(Part|Chapter|Section)\s+[IVX\d]+/.test(currentLineText) ||
                                (line.items.some(it => /Part|Chapter|Section/i.test(it.text)) &&
                                 line.items.some(it => /^[‚Ä¢|]$/.test(it.text.trim())))
                            );
                            const wasPrevPageHeader = currentParagraph.length > 0 && prevLineShort && (
                                /^(\d+\s*)?(Part|Chapter|Section).*[‚Ä¢|]/.test(prevLineText) ||
                                /^\d+\s+(Part|Chapter|Section)\s+[IVX\d]+/.test(prevLineText) ||
                                (currentParagraph[currentParagraph.length - 1].items.some(it => /Part|Chapter|Section/i.test(it.text)) &&
                                 currentParagraph[currentParagraph.length - 1].items.some(it => /^[‚Ä¢|]$/.test(it.text.trim())))
                            );

                            const isNewParagraph = largeGap ||
                                                  (prevLineEndsParagraph && isIndented) ||
                                                  fontSizeChanged ||
                                                  (mediumGap && prevLineShort) ||
                                                  (anyGap && wasPrevPageHeader) ||
                                                  isPageHeader ||
                                                  isStandaloneHeader;

                            if ((isNewParagraph || isHeading) && currentParagraph.length > 0) {
                                blocks.push({ type: 'paragraph', lines: currentParagraph });
                                currentParagraph = [];
                            }

                            currentParagraph.push(line);
                        }

                        lastLineY = line.y;
                    }
                });

                // Flush remaining paragraph or table
                if (currentParagraph.length > 0) {
                    if (currentParagraph[0].type === 'table') {
                        blocks.push(currentParagraph[0]);
                    } else {
                        blocks.push({ type: 'paragraph', lines: currentParagraph });
                    }
                }

                Logger.timeEnd('paragraphs', `Page ${i} block grouping`);

                const blockSummary = {
                    paragraphs: blocks.filter(b => b.type === 'paragraph').length,
                    tables: blocks.filter(b => b.type === 'table').length,
                    images: blocks.filter(b => b.type === 'image').length,
                    total: blocks.length
                };

                Logger.log('paragraphs', `Page ${i} - Block summary:`, blockSummary);


                // Render blocks
                blocks.forEach(block => {
                    if (block.type === 'image') {
                        pageHtml += `<div style="margin: 1.5em 0; text-align: center;">
                            <img src="${block.dataUrl}" style="max-width: 100%; height: auto; border: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,0.1);" alt="Extracted Image">
                        </div>`;
                    } else if (block.type === 'table') {
                        // Render as table
                        pageHtml += `<div style="margin: 1em 0; overflow-x: auto;">
                            <table style="border-collapse: collapse; width: auto; margin: 0 auto;">`;

                        block.rows.forEach((row, rowIdx) => {
                            pageHtml += `<tr>`;
                            row.items.forEach(item => {
                                const isBold = item.fontName.toLowerCase().includes('bold');
                                const fontSize = Math.round(item.height);
                                const isHeader = rowIdx === 0 || isBold;
                                const tag = isHeader ? 'th' : 'td';
                                const styles = [
                                    `font-size: ${fontSize}px`,
                                    'padding: 6px 12px',
                                    'border: 1px solid #ddd',
                                    'text-align: left'
                                ];
                                if (isBold) styles.push('font-weight: bold');
                                if (isHeader) styles.push('background: #f5f5f5');

                                pageHtml += `<${tag} style="${styles.join('; ')}">${item.text}</${tag}>`;
                            });
                            pageHtml += `</tr>`;
                        });

                        pageHtml += `</table></div>`;
                    } else if (block.type === 'paragraph') {
                        // Get all text items from lines
                        const allItems = block.lines ? block.lines.flatMap(line => line.items) : block.items || [];
                        if (allItems.length === 0) return;

                        const maxFontSize = Math.max(...allItems.map(it => it.height));
                        const isHeading = maxFontSize > 15;
                        const isLargeHeading = maxFontSize > 18;

                        if (isHeading) {
                            // Render as heading
                            let headingText = '';
                            allItems.forEach(item => {
                                const isBold = item.fontName.toLowerCase().includes('bold') ||
                                               item.fontName.toLowerCase().includes('black') ||
                                               item.fontName.toLowerCase().includes('heavy');
                                const isItalic = item.fontName.toLowerCase().includes('italic') ||
                                                 item.fontName.toLowerCase().includes('oblique');

                                const fontSize = Math.round(item.height);
                                let styles = [`font-size: ${fontSize}px`];

                                if (isBold) styles.push('font-weight: bold');
                                if (isItalic) styles.push('font-style: italic');

                                headingText += `<span style="${styles.join('; ')}">${item.text}</span>`;
                            });

                            const headingTag = isLargeHeading ? 'h2' : 'h3';
                            const marginTop = isLargeHeading ? '1.2em' : '1em';
                            pageHtml += `<${headingTag} style="margin: ${marginTop} 0 0.5em 0; line-height: 1.3;">${headingText}</${headingTag}>`;
                        } else {
                            // Render as paragraph with proper line structure
                            pageHtml += `<div style="margin-bottom: 1em; line-height: 1.6; white-space: pre-wrap;">`;

                            block.lines.forEach((line, lineIdx) => {
                                let lineText = '';
                                const lineItems = line.items;

                                // Check if line is a bullet point or list item
                                const firstText = lineItems[0]?.text.trim();
                                const isBullet = /^[\u2022\u2023\u25E6\u2043\u2219\-\*]/.test(firstText) ||
                                                /^[0-9]+[.)]/.test(firstText) ||
                                                /^[a-z][.)]/.test(firstText);

                                // Calculate indentation from left margin
                                const leftX = line.minX;
                                const baseMargin = Math.min(...block.lines.map(l => l.minX));
                                const relativeIndent = leftX - baseMargin;
                                const indentSpaces = Math.round(relativeIndent / 6); // Approximate spaces based on x-offset

                                // Detect definition terms: first item has different font and is short
                                const hasDefinitionTerm = lineItems.length > 1 &&
                                    lineItems[0].fontName !== lineItems[1].fontName &&
                                    lineItems[0].text.trim().length < 50 &&
                                    lineItems[0].text.trim().length > 2;

                                lineItems.forEach((item, idx) => {
                                    const isBold = item.fontName.toLowerCase().includes('bold') ||
                                                   item.fontName.toLowerCase().includes('black') ||
                                                   item.fontName.toLowerCase().includes('heavy');
                                    const isItalic = item.fontName.toLowerCase().includes('italic') ||
                                                     item.fontName.toLowerCase().includes('oblique');

                                    const fontSize = Math.round(item.height);
                                    let styles = [`font-size: ${fontSize}px`];

                                    if (isBold) styles.push('font-weight: bold');
                                    if (isItalic) styles.push('font-style: italic');

                                    const needsSpace = !item.text.endsWith(' ') && idx < lineItems.length - 1;

                                    // If this is a definition term (first item with different font), add line break after it
                                    if (hasDefinitionTerm && idx === 0) {
                                        lineText += `<span style="${styles.join('; ')}">${item.text}</span>\n`;
                                    } else {
                                        lineText += `<span style="${styles.join('; ')}">${item.text}${needsSpace ? ' ' : ''}</span>`;
                                    }
                                });

                                // Add indentation if present
                                const indentation = indentSpaces > 0 ? ' '.repeat(indentSpaces) : '';

                                // Check if this line ends a sentence or should break
                                const endsWithPunctuation = /[.!?:;]\s*$/.test(lineItems[lineItems.length - 1]?.text || '');
                                const nextLineIsBullet = lineIdx < block.lines.length - 1 &&
                                    /^[\u2022\u2023\u25E6\u2043\u2219\-\*]/.test(block.lines[lineIdx + 1]?.items[0]?.text.trim() || '') ||
                                    /^[0-9]+[.)]/.test(block.lines[lineIdx + 1]?.items[0]?.text.trim() || '');

                                // Check if the next line is significantly indented (suggests new paragraph)
                                const nextLineIndented = lineIdx < block.lines.length - 1 &&
                                    (block.lines[lineIdx + 1].minX - baseMargin) > 20;

                                if (isBullet) {
                                    // Render as list item with indentation preserved
                                    pageHtml += `${indentation}${lineText}\n`;
                                } else if (endsWithPunctuation || nextLineIsBullet || nextLineIndented || lineIdx === block.lines.length - 1) {
                                    // Complete sentence or last line - add line break
                                    pageHtml += `${indentation}${lineText}\n`;
                                } else {
                                    // Continuation within same line - no line break, just space
                                    pageHtml += `${lineText} `;
                                }
                            });

                            pageHtml += `</div>`;
                        }
                    }
                });                pageHtml += `</div>`;
                pages.push(pageHtml);
                html += pageHtml;

                Logger.timeEnd('performance', `Page ${i} processing`);
                Logger.log('performance', `Page ${i} - Processing complete`);
                Logger.groupEnd('pdfElements');
            }

            Logger.timeEnd('performance', 'PDF Conversion');
            Logger.log('performance', `PDF conversion complete - Total pages: ${pages.length}`);

            return { pages, html: html || '<p>No text content found in PDF</p>' };
        }

        async function convertWord(file) {
            Logger.time('performance', 'Word Document Conversion');
            Logger.log('performance', `Starting Word conversion: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`);

            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.convertToHtml({ arrayBuffer });
            const htmlContent = result.value || '<p>No content found in document</p>';

            Logger.log('wordPaging', `Word document converted to HTML (${htmlContent.length} characters)`);

            // Split content into pages (approximate page breaks)
            Logger.time('wordPaging', 'Page splitting');
            const pages = splitHtmlIntoPages(htmlContent);
            Logger.timeEnd('wordPaging', 'Page splitting');

            Logger.log('wordPaging', `Word document split into ${pages.length} pages`);
            Logger.timeEnd('performance', 'Word Document Conversion');

            return { pages, html: htmlContent };
        }

        function splitHtmlIntoPages(html) {
            Logger.log('wordPaging', 'Starting HTML page splitting...');

            // Create a temporary div to parse the HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            tempDiv.style.cssText = 'position: absolute; visibility: hidden; width: 800px; line-height: 1.6;';
            document.body.appendChild(tempDiv);

            const pages = [];
            let currentPage = '';
            let currentHeight = 0;
            const maxPageHeight = 1056; // Approximate A4 height in pixels (11 inches * 96 dpi)
            const pageMargin = 100;
            let pageNumber = 1;

            const children = Array.from(tempDiv.children);

            Logger.log('wordPaging', `Processing ${children.length} HTML elements`);

            children.forEach((element, idx) => {
                const clone = element.cloneNode(true);
                const testDiv = document.createElement('div');
                testDiv.style.cssText = 'position: absolute; visibility: hidden; width: 800px; line-height: 1.6;';
                testDiv.appendChild(clone);
                document.body.appendChild(testDiv);

                const elementHeight = testDiv.offsetHeight;
                document.body.removeChild(testDiv);

                // Check if adding this element would exceed page height
                if (currentHeight + elementHeight > maxPageHeight && currentPage.length > 0) {
                    // Save current page with page header
                    Logger.log('wordPaging', `Page ${pageNumber} complete:`, {
                        elements: currentPage.split('<').length - 1,
                        height: currentHeight,
                        maxHeight: maxPageHeight
                    });

                    const pageWithHeader = `<div style="margin-bottom: 2em;">
                        <div style="font-size: 10px; color: #999; margin-bottom: 1em; border-bottom: 1px solid #ddd; padding-bottom: 0.5em;">Page ${pageNumber}</div>
                        ${currentPage}
                    </div>`;
                    pages.push(pageWithHeader);
                    currentPage = '';
                    currentHeight = 0;
                    pageNumber++;
                }

                currentPage += element.outerHTML;
                currentHeight += elementHeight;
            });

            // Add the last page with page header
            if (currentPage.length > 0) {
                Logger.log('wordPaging', `Page ${pageNumber} (final) complete:`, {
                    elements: currentPage.split('<').length - 1,
                    height: currentHeight
                });

                const pageWithHeader = `<div style="margin-bottom: 2em;">
                    <div style="font-size: 10px; color: #999; margin-bottom: 1em; border-bottom: 1px solid #ddd; padding-bottom: 0.5em;">Page ${pageNumber}</div>
                    ${currentPage}
                </div>`;
                pages.push(pageWithHeader);
            }

            document.body.removeChild(tempDiv);

            Logger.log('wordPaging', `Total pages created: ${pages.length}`);

            return pages.length > 0 ? pages : [html];
        }

        window.panel1Api = setupPanel(1);
        window.panel2Api = setupPanel(2);
    </script>
</body>
</html>
