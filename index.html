<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 12px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 15px;
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .view-controls {
            text-align: center;
            margin-bottom: 12px;
        }

        .view-btn {
            padding: 6px 14px;
            margin: 0 4px;
            border: 2px solid white;
            background: rgba(255,255,255,0.2);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.3s;
        }

        .view-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .view-btn.active {
            background: white;
            color: #667eea;
        }

        .panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .panels.single-view {
            grid-template-columns: 1fr;
        }

        .panel.hidden {
            display: none;
        }

        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 800px;
        }

        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .panel-title {
            font-size: 1em;
            font-weight: 600;
        }

        .upload-area {
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255,255,255,0.1);
            font-size: 0.85em;
        }

        .upload-area:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.8);
        }

        .upload-area.dragover {
            background: rgba(255,255,255,0.3);
            border-color: white;
        }

        .file-input {
            display: none;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.75em;
            opacity: 0.9;
        }

        .font-adjust-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .page-nav {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .page-nav-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .page-nav-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.8);
        }

        .page-nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .page-select {
            padding: 4px 8px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.9);
            color: #667eea;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
        }

        .page-info {
            background: rgba(255,255,255,0.9);
            color: #667eea;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .search-box {
            display: flex;
            gap: 4px;
            flex: 1;
            max-width: 250px;
        }

        .search-input {
            flex: 1;
            padding: 4px 8px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 0.85em;
        }

        .search-input::placeholder {
            color: #999;
        }

        .search-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .search-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.8);
        }

        .highlight {
            background-color: yellow;
            font-weight: bold;
        }

        .current-match {
            background-color: #ff6600 !important;
            color: white !important;
            font-weight: bold;
            padding: 2px 0;
            border-radius: 2px;
        }

        .font-adjust-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.8);
        }

        .font-size-display {
            background: rgba(255,255,255,0.9);
            color: #667eea;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.85em;
            min-width: 40px;
            text-align: center;
        }

        .btn {
            padding: 4px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s;
            background: rgba(255,255,255,0.9);
            color: #667eea;
            font-weight: 600;
        }

        .btn:hover {
            background: white;
            transform: translateY(-1px);
        }

        .content-area {
            flex: 1;
            overflow-y: scroll;
            padding: 20px;
            background: #f8f9fa;
            height: calc(100vh - 180px);
        }

        .content-area.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 1.1em;
        }

        .document-content {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            line-height: 1.6;
        }

        .document-content h1, .document-content h2, .document-content h3,
        .document-content h4, .document-content h5, .document-content h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            color: #333;
        }

        .document-content p {
            margin-bottom: 1em;
        }

        .document-content ul, .document-content ol {
            margin-left: 2em;
            margin-bottom: 1em;
        }

        .document-content table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1em;
        }

        .document-content table td, .document-content table th {
            border: 1px solid #ddd;
            padding: 8px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.1em;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #e74c3c;
            font-size: 1.1em;
        }

        @media (max-width: 1024px) {
            .panels {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìÑ Document Converter</h1>

        <div class="view-controls">
            <button class="view-btn active" id="viewBoth">Both Documents</button>
            <button class="view-btn" id="viewDoc1">Document 1 Only</button>
            <button class="view-btn" id="viewDoc2">Document 2 Only</button>
            <button class="debug-btn" id="debugBtn">‚öôÔ∏è Debug Logging</button>
        </div>

        <div class="panels" id="panels">
            <!-- Left Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">Document 1</div>
                    <div class="upload-area" id="uploadArea1">
                        <input type="file" id="fileInput1" class="file-input" accept=".pdf,.doc,.docx">
                        <div>üìÅ Click or drag PDF/Word document here</div>
                    </div>
                    <div class="controls">
                        <div class="page-nav" id="pageNav1" style="display: none;">
                            <button class="page-nav-btn" id="firstPage1" title="First page">‚èÆ</button>
                            <button class="page-nav-btn" id="prevPage1" title="Previous page">‚óÄ</button>
                            <select class="page-select" id="pageSelect1"></select>
                            <button class="page-nav-btn" id="nextPage1" title="Next page">‚ñ∂</button>
                            <button class="page-nav-btn" id="lastPage1" title="Last page">‚è≠</button>
                        </div>
                        <div class="search-box">
                            <input type="text" class="search-input" id="searchInput1" placeholder="Search...">
                            <button class="search-btn" id="searchPrev1" title="Previous match">‚Üë</button>
                            <button class="search-btn" id="searchNext1" title="Next match">‚Üì</button>
                            <div class="page-info" id="searchInfo1" style="display: none; font-size: 0.75em; min-width: 60px;">0/0</div>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Font:</label>
                            <button class="font-adjust-btn" id="decreaseFont1">‚àí</button>
                            <div class="font-size-display" id="fontDisplay1">+0</div>
                            <button class="font-adjust-btn" id="increaseFont1">+</button>
                        </div>
                        <button class="btn" id="clearBtn1">Clear</button>
                    </div>
                </div>
                <div class="content-area empty" id="content1">
                    <div>No document loaded</div>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">Document 2</div>
                    <div class="upload-area" id="uploadArea2">
                        <input type="file" id="fileInput2" class="file-input" accept=".pdf,.doc,.docx">
                        <div>üìÅ Click or drag PDF/Word document here</div>
                    </div>
                    <div class="controls">
                        <div class="page-nav" id="pageNav2" style="display: none;">
                            <button class="page-nav-btn" id="firstPage2" title="First page">‚èÆ</button>
                            <button class="page-nav-btn" id="prevPage2" title="Previous page">‚óÄ</button>
                            <select class="page-select" id="pageSelect2"></select>
                            <button class="page-nav-btn" id="nextPage2" title="Next page">‚ñ∂</button>
                            <button class="page-nav-btn" id="lastPage2" title="Last page">‚è≠</button>
                        </div>
                        <div class="search-box">
                            <input type="text" class="search-input" id="searchInput2" placeholder="Search...">
                            <button class="search-btn" id="searchPrev2" title="Previous match">‚Üë</button>
                            <button class="search-btn" id="searchNext2" title="Next match">‚Üì</button>
                            <div class="page-info" id="searchInfo2" style="display: none; font-size: 0.75em; min-width: 60px;">0/0</div>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Font:</label>
                            <button class="font-adjust-btn" id="decreaseFont2">‚àí</button>
                            <div class="font-size-display" id="fontDisplay2">+0</div>
                            <button class="font-adjust-btn" id="increaseFont2">+</button>
                        </div>
                        <button class="btn" id="clearBtn2">Clear</button>
                    </div>
                </div>
                <div class="content-area empty" id="content2">
                    <div>No document loaded</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Debug configuration - set enabled: false to disable all logging
        const DEBUG_CONFIG = {
            enabled: true,
            areas: {
                pdfElements: true, wordPaging: true, tableFinding: true, imageFinding: true,
                textLayout: true, columnDetection: true, paragraphs: true, performance: true
            }
        };

        // Simplified logging utility
        const Logger = {
            enabled(area) { return DEBUG_CONFIG.enabled && DEBUG_CONFIG.areas[area]; },
            log(area, msg, data) { this.enabled(area) && console.log(`[${area.toUpperCase()}] ${msg}`, data || ''); },
            group(area, title) { this.enabled(area) && console.group(`[${area.toUpperCase()}] ${title}`); },
            groupEnd(area) { this.enabled(area) && console.groupEnd(); },
            table(area, data) { this.enabled(area) && console.table(data); },
            time(area, label) { this.enabled(area) && console.time(`[${area}] ${label}`); },
            timeEnd(area, label) { this.enabled(area) && console.timeEnd(`[${area}] ${label}`); }
        };

        // View control buttons
        const viewBothBtn = document.getElementById('viewBoth');
        const viewDoc1Btn = document.getElementById('viewDoc1');
        const viewDoc2Btn = document.getElementById('viewDoc2');
        const panelsDiv = document.getElementById('panels');
        const panel1 = document.querySelector('.panel:nth-child(1)');
        const panel2 = document.querySelector('.panel:nth-child(2)');

        viewBothBtn.addEventListener('click', () => {
            panelsDiv.classList.remove('single-view');
            panel1.classList.remove('hidden');
            panel2.classList.remove('hidden');
            setActiveButton(viewBothBtn);
        });

        viewDoc1Btn.addEventListener('click', () => {
            panelsDiv.classList.add('single-view');
            panel1.classList.remove('hidden');
            panel2.classList.add('hidden');
            setActiveButton(viewDoc1Btn);
        });

        viewDoc2Btn.addEventListener('click', () => {
            panelsDiv.classList.add('single-view');
            panel1.classList.add('hidden');
            panel2.classList.remove('hidden');
            setActiveButton(viewDoc2Btn);
        });

        function setActiveButton(activeBtn) {
            [viewBothBtn, viewDoc1Btn, viewDoc2Btn].forEach(btn => {
                btn.classList.remove('active');
            });
            activeBtn.classList.add('active');
        }

        function setupPanel(panelNum) {
            const uploadArea = document.getElementById(`uploadArea${panelNum}`);
            const fileInput = document.getElementById(`fileInput${panelNum}`);
            const content = document.getElementById(`content${panelNum}`);
            const increaseBtn = document.getElementById(`increaseFont${panelNum}`);
            const decreaseBtn = document.getElementById(`decreaseFont${panelNum}`);
            const fontDisplay = document.getElementById(`fontDisplay${panelNum}`);
            const clearBtn = document.getElementById(`clearBtn${panelNum}`);

            // Page navigation elements
            const pageNav = document.getElementById(`pageNav${panelNum}`);
            const firstPageBtn = document.getElementById(`firstPage${panelNum}`);
            const prevPageBtn = document.getElementById(`prevPage${panelNum}`);
            const pageSelect = document.getElementById(`pageSelect${panelNum}`);
            const nextPageBtn = document.getElementById(`nextPage${panelNum}`);
            const lastPageBtn = document.getElementById(`lastPage${panelNum}`);

            // Search elements
            const searchInput = document.getElementById(`searchInput${panelNum}`);
            const searchPrevBtn = document.getElementById(`searchPrev${panelNum}`);
            const searchNextBtn = document.getElementById(`searchNext${panelNum}`);
            const searchInfo = document.getElementById(`searchInfo${panelNum}`);

            let fontAdjustment = 0, pdfPages = [], currentPage = 0;
            let searchMatches = [], currentMatchIndex = -1, lastSearchTerm = '';
            let skipSearchOnPageChange = false;
            let pageTextIndex = [], isIndexing = false, indexingComplete = false;
            let rawPageData = [], pdfDocument = null, documentType = null, isNavigating = false;
            let isLoadingFromIndexSearch = false;
            let globalMatchPosition = 0, totalMatchesInDocument = 0;

            // Page navigation handlers
            firstPageBtn.addEventListener('click', () => goToPage(0));
            prevPageBtn.addEventListener('click', () => goToPage(currentPage - 1));
            nextPageBtn.addEventListener('click', () => goToPage(currentPage + 1));
            lastPageBtn.addEventListener('click', () => goToPage(pdfPages.length - 1));
            pageSelect.addEventListener('change', (e) => goToPage(parseInt(e.target.value)));

            async function goToPage(pageIndex) {
                if (pageIndex < 0 || pageIndex >= pdfPages.length) return;

                // Set navigation flag to prevent observer interference
                isNavigating = true;
                currentPage = pageIndex;

                // Scroll to the page
                const pageElement = content.querySelector(`#page${panelNum}-${pageIndex}`);
                if (pageElement) {
                    // Use instant scroll to avoid timing issues with IntersectionObserver
                    pageElement.scrollIntoView({ behavior: 'instant', block: 'start' });

                    // Trigger re-render to ensure this page and its buffer are rendered
                    const panelApi = window[`panel${panelNum}Api`];
                    if (panelApi && panelApi.rerenderVisiblePages) {
                        // Small delay to let scroll happen first
                        setTimeout(() => {
                            panelApi.rerenderVisiblePages();
                            // Clear navigation flag after rendering completes
                            setTimeout(() => { isNavigating = false; }, 300);
                        }, 50);
                    } else {
                        // Clear navigation flag if no rerender needed
                        setTimeout(() => { isNavigating = false; }, 100);
                    }
                }

                updatePageNav();

                // Re-run search to prioritize matches in new page (unless navigating from search or index search)
                if (!skipSearchOnPageChange && !isLoadingFromIndexSearch) {
                    const searchTerm = searchInput.value.trim();
                    if (searchTerm.length > 0) {
                        // Force re-search to update match priorities for new current page
                        lastSearchTerm = '';
                        await performSearch();
                    }
                } else {
                    // Reset flag for next navigation
                    skipSearchOnPageChange = false;
                }
            }

            function updatePageNav() {
                if (pdfPages.length === 0) return;
                pageSelect.value = currentPage;
                const isFirst = currentPage === 0, isLast = currentPage === pdfPages.length - 1;
                firstPageBtn.disabled = prevPageBtn.disabled = isFirst;
                nextPageBtn.disabled = lastPageBtn.disabled = isLast;
            }

            // Search handlers
            searchInput.addEventListener('keydown', (e) => e.key === 'Enter' && (e.preventDefault(), performSearch()));

            const handleSearchNav = async (direction) => {
                const currentTerm = searchInput.value.trim();
                if (!currentTerm) return;
                if (currentTerm !== lastSearchTerm) await performSearch();
                navigateMatch(direction);
            };

            searchPrevBtn.addEventListener('click', () => handleSearchNav(-1));
            searchNextBtn.addEventListener('click', () => handleSearchNav(1));

            async function performSearch() {
                const searchTerm = searchInput.value.trim();

                // If same search term, don't re-search
                if (searchTerm === lastSearchTerm && searchMatches.length > 0) {
                    return;
                }

                lastSearchTerm = searchTerm;
                let docContent = content.querySelector('.document-content');

                if (!docContent) return;

                // Search only in currently rendered (loaded) pages
                // Do NOT load all pages - keep lazy loading approach

                // Remove previous highlights
                const highlighted = docContent.querySelectorAll('.highlight');
                highlighted.forEach(el => {
                    const parent = el.parentNode;
                    const textNode = document.createTextNode(el.textContent);
                    parent.replaceChild(textNode, el);
                });
                // Normalize to merge adjacent text nodes
                docContent.normalize();

                searchMatches = [];
                currentMatchIndex = -1;

                if (searchTerm.length === 0) {
                    lastSearchTerm = '';
                    return;
                }

                const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedTerm, 'gi');

                // Find and highlight all matches
                const walker = document.createTreeWalker(docContent, NodeFilter.SHOW_TEXT);
                const nodesToProcess = [];
                let node;
                while (node = walker.nextNode()) {
                    const matches = [];
                    let match;
                    regex.lastIndex = 0;
                    while ((match = regex.exec(node.textContent)) !== null) {
                        matches.push({ index: match.index, length: searchTerm.length });
                    }
                    if (matches.length > 0) nodesToProcess.push({ node, matches });
                }

                // Apply highlights
                nodesToProcess.forEach(({ node, matches }) => {
                    const parent = node.parentNode;
                    if (!parent) return;

                    const fragments = [];
                    let lastIndex = 0;

                    matches.forEach(({ index, length }) => {
                        if (index > lastIndex) {
                            fragments.push(document.createTextNode(node.textContent.substring(lastIndex, index)));
                        }
                        const span = document.createElement('span');
                        span.className = 'highlight';
                        span.textContent = node.textContent.substring(index, index + length);
                        fragments.push(span);
                        searchMatches.push(span);
                        lastIndex = index + length;
                    });

                    if (lastIndex < node.textContent.length) {
                        fragments.push(document.createTextNode(node.textContent.substring(lastIndex)));
                    }

                    // Replace node with fragments
                    fragments.forEach(frag => parent.insertBefore(frag, node));
                    parent.removeChild(node);
                });

                if (searchMatches.length > 0) {
                    // Prioritize matches in current page, then forward, then backward
                    const currentPageElement = pdfPages.length > 0 ?
                        content.querySelector(`#page${panelNum}-${currentPage}`) : null;

                    if (currentPageElement) {
                        // Find matches within current page
                        const matchesInCurrentPage = searchMatches.filter(match =>
                            currentPageElement.contains(match)
                        );

                        if (matchesInCurrentPage.length > 0) {
                            // Start with first match in current page
                            currentMatchIndex = searchMatches.indexOf(matchesInCurrentPage[0]);
                        } else {
                            // Find first match in loaded pages after current page
                            let foundAfter = false;
                            for (let i = 0; i < searchMatches.length; i++) {
                                const matchPage = getPageForElement(searchMatches[i]);
                                if (matchPage > currentPage) {
                                    currentMatchIndex = i;
                                    foundAfter = true;
                                    break;
                                }
                            }
                            // If no match after, start from first match
                            if (!foundAfter) {
                                currentMatchIndex = 0;
                            }
                        }
                    } else {
                        // For non-PDF documents, find first match in viewport or start from beginning
                        currentMatchIndex = findClosestMatchToViewport();
                    }

                    scrollToMatch();
                } else {
                    // No matches found in loaded pages - check the index database for PDFs
                    // BUT: Don't trigger index search if we're already in the middle of loading from index search
                    if (!isLoadingFromIndexSearch && documentType === 'pdf' && pdfDocument && indexingComplete && searchTerm.length > 0) {
                        Logger.log('performance', `Panel ${panelNum} - No matches in loaded pages, searching index database...`);

                        const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const regex = new RegExp(escapedTerm, 'gi');

                        // Find all pages with matches in the index
                        const pagesWithMatches = [];
                        for (const pageData of pageTextIndex) {
                            if (regex.test(pageData.text)) {
                                pagesWithMatches.push(pageData.pageIndex);
                            }
                            regex.lastIndex = 0; // Reset regex
                        }

                        if (pagesWithMatches.length > 0) {
                            Logger.log('performance', `Panel ${panelNum} - Found matches in ${pagesWithMatches.length} pages via index`);

                            // Navigate to first page with match (preferring pages after current, then wrapping)
                            let targetPage = pagesWithMatches.find(p => p >= currentPage);
                            if (targetPage === undefined) {
                                targetPage = pagesWithMatches[0]; // Wrap to first match
                            }

                            // Check if we're already on the target page
                            if (targetPage === currentPage) {
                                Logger.log('performance', `Panel ${panelNum} - Already on target page, ensuring it's loaded`);
                                // Just ensure the page is loaded and re-render
                                isLoadingFromIndexSearch = true;
                                await ensurePageLoaded(targetPage);
                                await renderVisiblePages();
                                // Wait for rendering, then re-search
                                setTimeout(async () => {
                                    lastSearchTerm = ''; // Force re-search
                                    await performSearch();
                                    isLoadingFromIndexSearch = false;
                                }, 300);
                            } else {
                                // Set flag to prevent automatic re-search during page load
                                isLoadingFromIndexSearch = true;
                                skipSearchOnPageChange = true;

                                // Ensure the page is loaded first
                                await ensurePageLoaded(targetPage);

                                // Navigate to the page
                                await goToPage(targetPage);

                                // Wait for rendering to complete, then re-search once
                                setTimeout(async () => {
                                    lastSearchTerm = ''; // Force re-search
                                    await performSearch();
                                    isLoadingFromIndexSearch = false; // Clear flag after re-search
                                }, 500);
                            }
                        } else {
                            Logger.log('performance', `Panel ${panelNum} - No matches found in entire document`);
                            updateSearchInfo();
                        }
                    } else if (documentType === 'pdf' && pdfDocument && !indexingComplete && searchTerm.length > 0) {
                        Logger.log('performance', `Panel ${panelNum} - No matches in loaded pages. Index still building...`);
                        updateSearchInfo();
                    } else {
                        // Not a PDF or other condition - just update the info
                        updateSearchInfo();
                    }
                }

            }

            async function ensurePageLoaded(pageIndex) {
                if (pageIndex < 0 || pageIndex >= rawPageData.length || !pdfDocument) return;
                if (documentType === 'pdf' && rawPageData[pageIndex] === null) {
                    Logger.log('performance', `Panel ${panelNum} - Loading page ${pageIndex + 1}`);
                    rawPageData[pageIndex] = await convertPDFPage(pdfDocument, pageIndex + 1);
                    await renderVisiblePages();
                    // Only re-search if not loading from index search (to avoid loops)
                    if (!isLoadingFromIndexSearch) {
                        const searchTerm = searchInput.value.trim();
                        if (searchTerm.length > 0) {
                            lastSearchTerm = '';
                            await performSearch();
                        }
                    }
                }
            }

            function getPageForElement(element) {
                // Find which page contains this element
                for (let i = 0; i < pdfPages.length; i++) {
                    const pageElement = content.querySelector(`#page${panelNum}-${i}`);
                    if (pageElement && pageElement.contains(element)) {
                        return i;
                    }
                }
                return -1;
            }

            function findClosestMatchToViewport() {
                const scrollTop = content.scrollTop;
                const viewportMiddle = scrollTop + content.clientHeight / 2;

                let closestIndex = 0;
                let closestDistance = Infinity;

                searchMatches.forEach((match, index) => {
                    const rect = match.getBoundingClientRect();
                    const contentRect = content.getBoundingClientRect();
                    const matchTop = rect.top - contentRect.top + scrollTop;
                    const distance = Math.abs(matchTop - viewportMiddle);

                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestIndex = index;
                    }
                });

                return closestIndex;
            }

            // Background indexing function - extract ONLY text from PDF pages (no HTML rendering)
            async function buildSearchIndex() {
                if (isIndexing || indexingComplete) return;
                if (!pdfDocument || documentType !== 'pdf') return;

                isIndexing = true;
                Logger.log('performance', `Panel ${panelNum} - Starting background text extraction for ${pdfDocument.numPages} pages`);

                pageTextIndex = [];

                // Extract text directly from PDF pages (no HTML conversion)
                for (let i = 1; i <= pdfDocument.numPages; i++) {
                    try {
                        const page = await pdfDocument.getPage(i);
                        const textContent = await page.getTextContent();

                        // Combine all text items into a single string
                        const pageText = textContent.items.map(item => item.str).join(' ');

                        pageTextIndex.push({
                            pageIndex: i - 1, // Store as 0-based index
                            text: pageText
                        });

                        // Log progress every 10 pages
                        if (i % 10 === 0) {
                            Logger.log('performance', `Panel ${panelNum} - Extracted text from ${i}/${pdfDocument.numPages} pages`);
                        }

                        // Small delay to not block UI
                        if (i % 5 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    } catch (error) {
                        Logger.log('performance', `Panel ${panelNum} - Error extracting text from page ${i}: ${error.message}`);
                        // Add empty entry to maintain index
                        pageTextIndex.push({
                            pageIndex: i - 1,
                            text: ''
                        });
                    }
                }

                indexingComplete = true;
                isIndexing = false;
                Logger.log('performance', `Panel ${panelNum} - Background text extraction complete. Indexed ${pageTextIndex.length} pages`);
            }

            // Search using the index and navigate to page with match
            async function searchInIndex(searchTerm, direction) {
                if (!indexingComplete || pageTextIndex.length === 0) {
                    Logger.log('performance', `Panel ${panelNum} - Index not ready, searching visible pages only`);
                    return null; // Fall back to old search
                }

                const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedTerm, 'gi');

                // Find pages with matches
                const pagesWithMatches = [];
                for (const pageData of pageTextIndex) {
                    if (regex.test(pageData.text)) {
                        pagesWithMatches.push(pageData.pageIndex);
                    }
                    regex.lastIndex = 0; // Reset regex
                }

                if (pagesWithMatches.length === 0) {
                    Logger.log('performance', `Panel ${panelNum} - No matches found in document`);
                    return null;
                }

                Logger.log('performance', `Panel ${panelNum} - Found matches in ${pagesWithMatches.length} pages`);

                // Find next/previous page with match based on current page and direction
                let targetPage = null;

                if (direction > 0) {
                    // Find first page with match after current page
                    targetPage = pagesWithMatches.find(p => p > currentPage);
                    if (!targetPage) {
                        // Wrap to first page with match
                        targetPage = pagesWithMatches[0];
                    }
                } else {
                    // Find last page with match before current page
                    const reversed = [...pagesWithMatches].reverse();
                    targetPage = reversed.find(p => p < currentPage);
                    if (targetPage === undefined) {
                        // Wrap to last page with match
                        targetPage = pagesWithMatches[pagesWithMatches.length - 1];
                    }
                }

                return targetPage;
            }

            async function navigateMatch(direction) {
                if (searchMatches.length === 0) return;

                const searchTerm = searchInput.value.trim();
                if (!searchTerm) return;

                // For PDFs with index, navigate by global position
                if (documentType === 'pdf' && pdfDocument && indexingComplete) {
                    // Get current global position
                    const currentGlobalPos = calculateGlobalMatchPosition();
                    const totalMatches = countTotalMatches(searchTerm);

                    // Calculate target global position
                    let targetGlobalPos = currentGlobalPos + direction;

                    // Wrap around if needed
                    if (targetGlobalPos < 1) {
                        targetGlobalPos = totalMatches;
                    } else if (targetGlobalPos > totalMatches) {
                        targetGlobalPos = 1;
                    }

                    Logger.log('performance', `Panel ${panelNum} - Navigating from match ${currentGlobalPos}/${totalMatches} to ${targetGlobalPos}/${totalMatches}`);

                    // Find which page contains the target match
                    const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(escapedTerm, 'gi');

                    let accumulatedMatches = 0;
                    let targetPage = -1;
                    let matchIndexInTargetPage = -1;

                    for (let pageIdx = 0; pageIdx < pageTextIndex.length; pageIdx++) {
                        let matchesInThisPage = 0;
                        let match;
                        regex.lastIndex = 0;
                        while ((match = regex.exec(pageTextIndex[pageIdx].text)) !== null) {
                            matchesInThisPage++;
                            if (accumulatedMatches + matchesInThisPage === targetGlobalPos) {
                                targetPage = pageIdx;
                                matchIndexInTargetPage = matchesInThisPage;
                                break;
                            }
                        }

                        if (targetPage !== -1) break;
                        accumulatedMatches += matchesInThisPage;
                    }

                    if (targetPage === -1) {
                        Logger.log('performance', `Panel ${panelNum} - Could not find target match`);
                        return;
                    }

                    // Check if target match is already in loaded pages
                    const targetPageElement = content.querySelector(`#page${panelNum}-${targetPage}`);

                    if (targetPageElement && !targetPageElement.classList.contains('pdf-page-placeholder')) {
                        // Page is already loaded, find the match in the loaded page
                        let foundMatchIndex = -1;
                        let matchCount = 0;

                        for (let i = 0; i < searchMatches.length; i++) {
                            if (targetPageElement.contains(searchMatches[i])) {
                                matchCount++;
                                if (matchCount === matchIndexInTargetPage) {
                                    foundMatchIndex = i;
                                    break;
                                }
                            }
                        }

                        if (foundMatchIndex !== -1) {
                            currentMatchIndex = foundMatchIndex;
                            scrollToMatch();
                            return;
                        }
                    }

                    // Need to load the target page
                    Logger.log('performance', `Panel ${panelNum} - Loading page ${targetPage + 1} for match ${targetGlobalPos}`);

                    isLoadingFromIndexSearch = true;
                    skipSearchOnPageChange = true;

                    await goToPage(targetPage);
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Re-search to populate matches
                    lastSearchTerm = '';
                    await performSearch();

                    isLoadingFromIndexSearch = false;
                    skipSearchOnPageChange = false;

                    // Find the exact match we want on this page
                    const newPageElement = content.querySelector(`#page${panelNum}-${targetPage}`);
                    if (newPageElement && searchMatches.length > 0) {
                        let matchCount = 0;
                        let foundMatchIndex = -1;

                        for (let i = 0; i < searchMatches.length; i++) {
                            if (newPageElement.contains(searchMatches[i])) {
                                matchCount++;
                                if (matchCount === matchIndexInTargetPage) {
                                    foundMatchIndex = i;
                                    break;
                                }
                            }
                        }

                        if (foundMatchIndex !== -1) {
                            currentMatchIndex = foundMatchIndex;
                            scrollToMatch();
                            return;
                        }
                    }

                    // Fallback
                    Logger.log('performance', `Panel ${panelNum} - Could not locate exact match after loading page`);
                    currentMatchIndex = 0;
                    scrollToMatch();
                } else {
                    // Simple navigation for non-PDF or without index
                    let nextIndex = currentMatchIndex + direction;

                    if (nextIndex < 0) {
                        nextIndex = searchMatches.length - 1;
                    } else if (nextIndex >= searchMatches.length) {
                        nextIndex = 0;
                    }

                    currentMatchIndex = nextIndex;
                    scrollToMatch();
                }
            }

            function scrollToMatch() {
                if (currentMatchIndex >= 0 && currentMatchIndex < searchMatches.length) {
                    // Remove current-match class from all matches
                    searchMatches.forEach(match => match.classList.remove('current-match'));

                    // Add current-match class to the active match
                    searchMatches[currentMatchIndex].classList.add('current-match');

                    // Temporarily set navigation flag to prevent observer interference
                    isNavigating = true;
                    searchMatches[currentMatchIndex].scrollIntoView({ behavior: 'instant', block: 'center' });
                    // Clear flag after instant scroll
                    setTimeout(() => { isNavigating = false; }, 100);
                }

                updateSearchInfo();
            }

            // Count total matches across entire document using index
            function countTotalMatches(searchTerm) {
                if (!searchTerm || searchTerm.length === 0) return 0;

                // For PDFs with completed index, count matches in the index
                if (documentType === 'pdf' && indexingComplete && pageTextIndex.length > 0) {
                    const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(escapedTerm, 'gi');

                    let totalMatches = 0;
                    for (const pageData of pageTextIndex) {
                        // Count matches properly with regex
                        let match;
                        regex.lastIndex = 0;
                        while ((match = regex.exec(pageData.text)) !== null) {
                            totalMatches++;
                        }
                    }

                    return totalMatches;
                }

                // Fallback: return loaded page matches only
                return searchMatches.length;
            }

            // Calculate global match position entirely from database
            function calculateGlobalMatchPosition() {
                if (currentMatchIndex < 0 || searchMatches.length === 0) return 0;

                const searchTerm = searchInput.value.trim();

                // For non-PDF or no index, use simple position in loaded matches
                if (!searchTerm || documentType !== 'pdf' || !indexingComplete) {
                    return currentMatchIndex + 1;
                }

                // Step 1: Find which page the current match is on
                let matchPage = currentPage;
                const currentMatch = searchMatches[currentMatchIndex];
                if (currentMatch) {
                    // Check each loaded page to find which one contains the current match
                    for (let i = 0; i < pdfPages.length; i++) {
                        const pageElement = content.querySelector(`#page${panelNum}-${i}`);
                        if (pageElement && pageElement.contains(currentMatch)) {
                            matchPage = i;
                            break;
                        }
                    }
                }

                // Step 2: Count which match number this is within its page (1-based)
                let matchPositionInPage = 0;
                const pageElement = content.querySelector(`#page${panelNum}-${matchPage}`);
                if (pageElement) {
                    for (let i = 0; i < searchMatches.length; i++) {
                        if (pageElement.contains(searchMatches[i])) {
                            matchPositionInPage++;
                            if (i === currentMatchIndex) {
                                // Found our match
                                break;
                            }
                        }
                    }
                }

                // Step 3: Count matches in all pages before this page from database
                const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedTerm, 'gi');

                let matchesBeforePage = 0;
                for (let i = 0; i < matchPage; i++) {
                    if (i < pageTextIndex.length) {
                        let match;
                        regex.lastIndex = 0;
                        while ((match = regex.exec(pageTextIndex[i].text)) !== null) {
                            matchesBeforePage++;
                        }
                    }
                }

                // Step 4: Global position = matches before this page + position in current page
                return matchesBeforePage + matchPositionInPage;
            }            function updateSearchInfo() {
                const searchTerm = searchInput.value.trim();

                if (searchMatches.length > 0) {
                    // Calculate global position and total
                    globalMatchPosition = calculateGlobalMatchPosition();
                    totalMatchesInDocument = countTotalMatches(searchTerm);

                    searchInfo.textContent = `${globalMatchPosition}/${totalMatchesInDocument}`;
                    searchInfo.style.display = 'block';
                } else if (searchTerm.length > 0) {
                    // No matches in loaded pages, but check if there are any in the document
                    totalMatchesInDocument = countTotalMatches(searchTerm);

                    if (totalMatchesInDocument > 0) {
                        searchInfo.textContent = `0/${totalMatchesInDocument}`;
                    } else {
                        searchInfo.textContent = '0/0';
                    }
                    searchInfo.style.display = 'block';
                } else {
                    searchInfo.style.display = 'none';
                }
            }

            uploadArea.addEventListener('click', () => fileInput.click());

            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file) handleFile(file, content, fontAdjustment, panelNum);
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFile(file, content, fontAdjustment, panelNum);
            });

            const updateFont = (delta) => {
                fontAdjustment += delta;
                fontDisplay.textContent = fontAdjustment >= 0 ? `+${fontAdjustment}` : fontAdjustment;
                const panelApi = window[`panel${panelNum}Api`];
                panelApi?.rerenderVisiblePages?.();
            };

            increaseBtn.addEventListener('click', () => updateFont(1));
            decreaseBtn.addEventListener('click', () => updateFont(-1));

            clearBtn.addEventListener('click', () => {
                content.innerHTML = '<div>No document loaded</div>';
                content.classList.add('empty');
                fileInput.value = '';
                fontAdjustment = 0;
                fontDisplay.textContent = '+0';
                pdfPages = [];
                currentPage = 0;
                pageNav.style.display = 'none';
                searchInput.value = '';
                searchMatches = [];
                currentMatchIndex = -1;
                lastSearchTerm = '';
                updateSearchInfo();
                window[`panel${panelNum}Api`]?.setContent?.('');
            });

            let pageObserver = null;
            let renderTimeout = null;

            function setupPageObserver() {
                pageObserver?.disconnect();
                pageObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (!entry.isIntersecting) return;
                        const pageElement = entry.target;
                        const pageIndex = parseInt(pageElement.dataset.pageIndex);

                        if (!isNavigating && pageIndex !== currentPage) {
                            currentPage = pageIndex;
                            updatePageNav();
                        }

                        if (pageElement.classList.contains('pdf-page-placeholder')) {
                            clearTimeout(renderTimeout);
                            renderTimeout = setTimeout(() => renderVisiblePages(), 200);
                        }
                    });
                }, { root: content, rootMargin: '50px', threshold: 0.1 });

                content.querySelectorAll('.pdf-page').forEach(page => pageObserver.observe(page));
            }

            // Apply font adjustment to HTML
            const applyFontToPageHtml = (pageHtml, adjustment) => adjustment === 0 ? pageHtml :
                pageHtml.replace(/font-size:\s*(\d+(?:\.\d+)?)px/g, (_, size) =>
                    `font-size: ${Math.max(6, parseFloat(size) + adjustment)}px`);

            // Modified renderVisiblePages to handle lazy loading
            async function renderVisiblePages() {
                if (rawPageData.length === 0) return;

                const BUFFER_SIZE = 3;
                const startPage = Math.max(0, currentPage - BUFFER_SIZE);
                const endPage = Math.min(rawPageData.length - 1, currentPage + BUFFER_SIZE);

                Logger.log('performance', `Panel ${panelNum} - Rendering pages ${startPage} to ${endPage} (current: ${currentPage})`);

                // Load pages if needed (for PDF lazy loading)
                if (documentType === 'pdf' && pdfDocument) {
                    for (let i = startPage; i <= endPage; i++) {
                        if (rawPageData[i] === null) {
                            rawPageData[i] = await convertPDFPage(pdfDocument, i + 1);
                        }
                    }
                }

                // Create placeholder structure with only visible pages rendered
                let allPagesHtml = '<div class="document-content">';

                for (let i = 0; i < rawPageData.length; i++) {
                    if (i >= startPage && i <= endPage && rawPageData[i] !== null) {
                        // Render this page with current font adjustment
                        const renderedPage = applyFontToPageHtml(rawPageData[i], fontAdjustment);
                        allPagesHtml += `<div id="page${panelNum}-${i}" class="pdf-page" data-page-index="${i}" style="margin-bottom: 2em;">${renderedPage}</div>`;
                    } else {
                        // Placeholder for unrendered pages
                        const estimatedHeight = i === 0 ? 1000 : 800;
                        allPagesHtml += `<div id="page${panelNum}-${i}" class="pdf-page pdf-page-placeholder" data-page-index="${i}" style="min-height: ${estimatedHeight}px; margin-bottom: 2em; background: #f5f5f5; display: flex; align-items: center; justify-content: center; color: #999;">
                            <div>Page ${i + 1} (not rendered)</div>
                        </div>`;
                    }
                }

                allPagesHtml += '</div>';
                content.innerHTML = allPagesHtml;

                setupPageObserver();

                // Re-apply search highlights if active (but not when loading from index search)
                if (!isLoadingFromIndexSearch) {
                    const searchTerm = searchInput.value.trim();
                    if (searchTerm.length > 0 && lastSearchTerm === searchTerm) {
                        const savedMatchIndex = currentMatchIndex;
                        lastSearchTerm = '';
                        await performSearch();
                        if (savedMatchIndex >= 0 && savedMatchIndex < searchMatches.length) {
                            currentMatchIndex = savedMatchIndex;
                            scrollToMatch();
                        }
                    }
                }
            }

            // Return API for external access
            return {
                setPDFDocument: async (pdfDoc, numPages) => {
                    pdfDocument = pdfDoc;
                    documentType = 'pdf';
                    pdfPages = rawPageData = new Array(numPages).fill(null);
                    currentPage = 0;
                    pageTextIndex = [];
                    indexingComplete = isIndexing = false;

                    pageSelect.innerHTML = Array.from({length: numPages}, (_, i) =>
                        `<option value="${i}">Page ${i + 1}</option>`).join('');

                    pageNav.style.display = 'flex';
                    updatePageNav();
                    await renderVisiblePages();
                    setTimeout(() => buildSearchIndex(), 100);
                },
                setAllPages: (pages, fullHtml) => {
                    rawPageData = pdfPages = pages;
                    documentType = 'word';
                    currentPage = 0;
                    pageSelect.innerHTML = Array.from({length: pages.length}, (_, i) =>
                        `<option value="${i}">Page ${i + 1}</option>`).join('');
                    pageNav.style.display = 'flex';
                    updatePageNav();
                    renderVisiblePages();
                },
                setContent: (html) => {
                    content.innerHTML = `<div class="document-content">${html}</div>`;
                    pageNav.style.display = 'none';
                    pdfPages = rawPageData = [];
                    pdfDocument = documentType = null;
                },
                rerenderVisiblePages: () => renderVisiblePages()
            };
        }

        async function handleFile(file, contentDiv, fontAdjustment, panelNum) {
            const fileName = file.name.toLowerCase();

            contentDiv.classList.remove('empty');
            contentDiv.innerHTML = '<div class="loading">‚è≥ Converting document...</div>';

            try {
                const panelApi = window[`panel${panelNum}Api`];
                if (fileName.endsWith('.pdf')) {
                    const result = await convertPDF(file);
                    await panelApi.setPDFDocument(result.pdfDoc, result.numPages);
                } else if (fileName.endsWith('.docx') || fileName.endsWith('.doc')) {
                    const result = await convertWord(file);
                    panelApi.setAllPages(result.pages, result.html);
                } else {
                    throw new Error('Unsupported file format');
                }
            } catch (error) {
                contentDiv.innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function convertPDF(file) {
            Logger.time('performance', 'PDF Conversion');
            const pdf = await pdfjsLib.getDocument({ data: await file.arrayBuffer() }).promise;
            return { pdfDoc: pdf, numPages: pdf.numPages, isLazyLoad: true };
        }

        async function convertPDFPage(pdfDoc, pageNumber) {
            const i = pageNumber;
            Logger.group('pdfElements', `===== PAGE ${i} of ${pdfDoc.numPages} =====`);
            Logger.time('performance', `Page ${i} processing`);

            const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: 1.5 });
                const pageHeight = viewport.height;
                const pageWidth = viewport.width;

                Logger.log('pdfElements', `Page ${i} dimensions:`, {
                    width: pageWidth.toFixed(2),
                    height: pageHeight.toFixed(2),
                    scale: 1.5
                });

                let pageHtml = `<div style="margin-bottom: 2em;">`;
                pageHtml += `<div style="font-size: 10px; color: #999; margin-bottom: 1em; border-bottom: 1px solid #ddd; padding-bottom: 0.5em;">Page ${i}</div>`;

                // Get all content items (text and images) with their positions
                const textContent = await page.getTextContent();
                Logger.log('pdfElements', `Page ${i} - Total text items found: ${textContent.items.length}`);

                // SIMPLE APPROACH: Render entire page, extract images separately,
                // then insert images at gaps in text based on Y-coordinate analysis

                // Extract images with their data
                Logger.time('imageFinding', `Page ${i} image extraction`);
                const imageItems = [];
                const ops = await page.getOperatorList();

                Logger.log('imageFinding', `Page ${i} - Total operations: ${ops.fnArray.length}`);

                for (let j = 0; j < ops.fnArray.length; j++) {
                    if (ops.fnArray[j] === pdfjsLib.OPS.paintImageXObject ||
                        ops.fnArray[j] === pdfjsLib.OPS.paintInlineImageXObject ||
                        ops.fnArray[j] === pdfjsLib.OPS.paintJpegXObject ||
                        ops.fnArray[j] === pdfjsLib.OPS.paintFormXObjectBegin) {

                        const imageName = ops.argsArray[j][0];
                        Logger.log('imageFinding', `Page ${i} - Found image operation: ${imageName}`);

                        try {
                            const img = await new Promise((resolve) => {
                                page.commonObjs.get(imageName, resolve);
                                page.objs.get(imageName, resolve);
                                setTimeout(() => resolve(null), 100);
                            });

                            if (img) {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                let width = img.width || 200;
                                let height = img.height || 200;

                                canvas.width = width;
                                canvas.height = height;

                                if (img instanceof HTMLImageElement) {
                                    ctx.drawImage(img, 0, 0);
                                } else if (img instanceof HTMLCanvasElement) {
                                    ctx.drawImage(img, 0, 0);
                                } else if (img.bitmap) {
                                    ctx.drawImage(img.bitmap, 0, 0);
                                } else if (img.data) {
                                    const imgData = ctx.createImageData(img.width, img.height);
                                    const data = img.data;

                                    if (img.kind === 1) {
                                        for (let k = 0; k < img.width * img.height; k++) {
                                            const gray = data[k];
                                            imgData.data[k * 4] = gray;
                                            imgData.data[k * 4 + 1] = gray;
                                            imgData.data[k * 4 + 2] = gray;
                                            imgData.data[k * 4 + 3] = 255;
                                        }
                                    } else {
                                        const numComponents = data.length / (img.width * img.height);
                                        for (let k = 0; k < img.width * img.height; k++) {
                                            if (numComponents === 3) {
                                                imgData.data[k * 4] = data[k * 3];
                                                imgData.data[k * 4 + 1] = data[k * 3 + 1];
                                                imgData.data[k * 4 + 2] = data[k * 3 + 2];
                                                imgData.data[k * 4 + 3] = 255;
                                            } else if (numComponents === 4) {
                                                imgData.data[k * 4] = data[k * 4];
                                                imgData.data[k * 4 + 1] = data[k * 4 + 1];
                                                imgData.data[k * 4 + 2] = data[k * 4 + 2];
                                                imgData.data[k * 4 + 3] = data[k * 4 + 3];
                                            }
                                        }
                                    }
                                    ctx.putImageData(imgData, 0, 0);
                                }

                                const imgDataUrl = canvas.toDataURL('image/png');
                                // Filter out tiny images (likely decorative or artifacts)
                                // Keep images that are at least 50x50 pixels
                                if (imgDataUrl && imgDataUrl.length > 100 && width >= 50 && height >= 50) {
                                    imageItems.push({ dataUrl: imgDataUrl });
                                    Logger.log('imageFinding', `Page ${i} - Image ${imageItems.length} extracted:`, {
                                        width: width,
                                        height: height,
                                        dataSize: `${(imgDataUrl.length / 1024).toFixed(2)} KB`
                                    });
                                } else {
                                    Logger.log('imageFinding', `Page ${i} - Image skipped (too small or invalid):`, {
                                        width: width,
                                        height: height
                                    });
                                }
                            }
                        } catch (err) {
                            Logger.log('imageFinding', `Page ${i} - Could not extract image: ${err.message}`);
                        }
                    }
                }

                Logger.timeEnd('imageFinding', `Page ${i} image extraction`);
                Logger.log('imageFinding', `Page ${i} - Total images extracted: ${imageItems.length}`);

                // Build content using text coordinates and detect gaps for images

                // ENHANCED APPROACH: Detect columns, tables, and complex layouts

                // Analyze page width to detect columns
                Logger.time('textLayout', `Page ${i} text layout analysis`);

                const leftMargin = Math.min(...textContent.items.map(it => it.transform[4]));
                const rightMargin = Math.max(...textContent.items.map(it => it.transform[4] + (it.width || 0)));
                const contentWidth = rightMargin - leftMargin;

                Logger.log('textLayout', `Page ${i} - Content boundaries:`, {
                    leftMargin: leftMargin.toFixed(2),
                    rightMargin: rightMargin.toFixed(2),
                    contentWidth: contentWidth.toFixed(2)
                });

                // Sort text items by Y position first, then X (for reading order)
                const textItems = textContent.items
                    .filter(item => item.str && item.str.trim().length > 0) // Skip empty text items
                    .map(item => ({
                        x: item.transform[4],
                        y: item.transform[5],  // baseline Y
                        pdfTop: item.transform[5] + (item.height || 12),
                        width: item.width || 0,
                        height: item.height || 12,
                        text: item.str,
                        fontName: item.fontName || ''
                    }));

                // Log all text elements with coordinates
                Logger.log('pdfElements', `Page ${i} - Text elements (first 10):`,
                    textItems.slice(0, 100).map((item, idx) => ({
                        index: idx,
                        text: item.text,
                        x: item.x.toFixed(2),
                        y: item.y.toFixed(2),
                        width: item.width.toFixed(2),
                        height: item.height.toFixed(2),
                        font: item.fontName
                    }))
                );

                if (textItems.length > 10) {
                    Logger.log('pdfElements', `Page ${i} - ...and ${textItems.length - 10} more text elements`);
                }

                // Detect columns from raw text items
                Logger.time('columnDetection', `Page ${i} column detection`);

                const detectColumnsFromItems = (items) => {
                    if (items.length === 0) return { hasColumns: false, columns: [] };

                    // Simple approach: Group items by their X position (rounded to nearest 5px)
                    const xGroups = {};
                    items.forEach(item => {
                        const xKey = Math.round(item.x / 5) * 5;
                        if (!xGroups[xKey]) {
                            xGroups[xKey] = [];
                        }
                        xGroups[xKey].push(item);
                    });

                    // Find X positions that have significant number of items (at least 10% of total)
                    const minItems = Math.max(10, Math.floor(items.length * 0.1));
                    const significantXs = Object.entries(xGroups)
                        .filter(([x, items]) => items.length >= minItems)
                        .map(([x, items]) => ({ x: parseFloat(x), count: items.length }))
                        .sort((a, b) => a.x - b.x);

                    Logger.log('columnDetection', `Page ${i} - Significant X positions found (min ${minItems} items):`,
                        significantXs.map(s => ({ x: s.x, count: s.count }))
                    );

                    // Merge nearby X positions (within 30px)
                    const mergedXs = [];
                    significantXs.forEach(xPos => {
                        if (mergedXs.length === 0 || xPos.x - mergedXs[mergedXs.length - 1].x > 30) {
                            mergedXs.push({ x: xPos.x, count: xPos.count });
                        } else {
                            const prev = mergedXs[mergedXs.length - 1];
                            prev.x = (prev.x * prev.count + xPos.x * xPos.count) / (prev.count + xPos.count);
                            prev.count += xPos.count;
                        }
                    });

                    Logger.log('columnDetection', `Page ${i} - After merging (within 30px):`,
                        mergedXs.map(m => ({ x: m.x.toFixed(2), count: m.count }))
                    );

                    // If we have at least 2 distinct X positions with gap > 70px, we have columns
                    const hasColumns = mergedXs.length >= 2 &&
                                      mergedXs.some((xPos, idx) =>
                                          idx > 0 && xPos.x - mergedXs[idx-1].x > 70
                                      );

                    if (hasColumns) {
                        // Create columns based on these X positions
                        const columns = mergedXs.map((xPos, idx) => {
                            const nextX = mergedXs[idx + 1];

                            return {
                                index: idx,
                                leftEdge: xPos.x - 10,
                                rightEdge: nextX ? (xPos.x + nextX.x) / 2 : 9999,
                                centerX: xPos.x,
                                itemCount: xPos.count
                            };
                        });

                        return { hasColumns: true, columns };
                    }

                    return { hasColumns: false, columns: [] };
                };                const columnInfo = detectColumnsFromItems(textItems);

                if (columnInfo.hasColumns) {
                    Logger.log('columnDetection', `Page ${i} - Multi-column layout detected:`, {
                        columnCount: columnInfo.columns.length,
                        columns: columnInfo.columns.map(c => ({
                            index: c.index,
                            leftEdge: c.leftEdge.toFixed(2),
                            rightEdge: c.rightEdge.toFixed(2),
                            centerX: c.centerX.toFixed(2),
                            itemCount: c.itemCount
                        }))
                    });

                    // Assign column index to each text item
                    textItems.forEach(item => {
                        item.columnIndex = -1; // Default: no column assigned
                        for (let col of columnInfo.columns) {
                            if (item.x >= col.leftEdge && item.x < col.rightEdge) {
                                item.columnIndex = col.index;
                                break;
                            }
                        }
                        // If still not assigned, assign to closest column
                        if (item.columnIndex === -1) {
                            let minDist = Infinity;
                            columnInfo.columns.forEach(col => {
                                const dist = Math.min(
                                    Math.abs(item.x - col.leftEdge),
                                    Math.abs(item.x - col.rightEdge)
                                );
                                if (dist < minDist) {
                                    minDist = dist;
                                    item.columnIndex = col.index;
                                }
                            });
                        }
                    });

                    Logger.log('columnDetection', `Page ${i} - Column assignment summary:`,
                        columnInfo.columns.map(col => ({
                            column: col.index,
                            itemCount: textItems.filter(it => it.columnIndex === col.index).length
                        }))
                    );
                } else {
                    // Assign all items to column 0
                    textItems.forEach(item => {
                        item.columnIndex = 0;
                    });
                    Logger.log('columnDetection', `Page ${i} - Single column layout`);
                }

                Logger.timeEnd('columnDetection', `Page ${i} column detection`);

                // Sort text items in natural reading order based on coordinates
                Logger.time('textLayout', `Page ${i} text sorting`);

                if (columnInfo.hasColumns) {
                    // Multi-column: sort by column first (left to right), then by Y (top to bottom) within each column
                    textItems.sort((a, b) => {
                        // Primary: column order (left to right)
                        const colA = a.columnIndex !== undefined ? a.columnIndex : 0;
                        const colB = b.columnIndex !== undefined ? b.columnIndex : 0;
                        const colDiff = colA - colB;
                        if (colDiff !== 0) return colDiff;

                        // Secondary: top to bottom within same column (higher y = higher on page)
                        const yDiff = b.pdfTop - a.pdfTop;
                        if (Math.abs(yDiff) > 2) return yDiff;

                        // Tertiary: left to right within same line
                        return a.x - b.x;
                    });

                    Logger.log('textLayout', `Page ${i} - First 20 items after sorting:`,
                        textItems.slice(0, 20).map((item, idx) => ({
                            idx,
                            col: item.columnIndex,
                            x: item.x.toFixed(2),
                            y: item.pdfTop.toFixed(2),
                            text: item.text.substring(0, 40)
                        }))
                    );

                    Logger.log('textLayout', `Page ${i} - Items 70-90 after sorting:`,
                        textItems.slice(70, 90).map((item, idx) => ({
                            idx: idx + 70,
                            col: item.columnIndex,
                            x: item.x.toFixed(2),
                            y: item.pdfTop.toFixed(2),
                            text: item.text.substring(0, 40)
                        }))
                    );
                } else {
                    // Single column: simple top-to-bottom, left-to-right
                    textItems.sort((a, b) => {
                        const yDiff = b.pdfTop - a.pdfTop;
                        if (Math.abs(yDiff) > 2) return yDiff;
                        return a.x - b.x;
                    });
                }

                Logger.timeEnd('textLayout', `Page ${i} text sorting`);

                // Now group sorted text items into lines
                Logger.time('textLayout', `Page ${i} line grouping`);
                const lines = [];
                let currentLine = [];
                let lastY = null;

                textItems.forEach(item => {
                    const tolerance = (item.height || 12) * 0.1; // 10% tolerance
                    const yChanged = lastY !== null && Math.abs(item.y - lastY) > tolerance;

                    if (yChanged) {
                        // Save current line
                        if (currentLine.length > 0) {
                            lines.push({
                                items: currentLine,
                                y: currentLine[0].y,
                                pdfTop: Math.max(...currentLine.map(it => it.pdfTop)),
                                avgHeight: currentLine.reduce((sum, it) => sum + it.height, 0) / currentLine.length,
                                minX: Math.min(...currentLine.map(it => it.x)),
                                maxX: Math.max(...currentLine.map(it => it.x + it.width)),
                                columnIndex: currentLine[0].columnIndex
                            });
                            currentLine = [];
                        }
                    }

                    currentLine.push(item);
                    lastY = item.y;
                });

                // Add last line
                if (currentLine.length > 0) {
                    lines.push({
                        items: currentLine,
                        y: currentLine[0].y,
                        pdfTop: Math.max(...currentLine.map(it => it.pdfTop)),
                        avgHeight: currentLine.reduce((sum, it) => sum + it.height, 0) / currentLine.length,
                        minX: Math.min(...currentLine.map(it => it.x)),
                        maxX: Math.max(...currentLine.map(it => it.x + it.width)),
                        columnIndex: currentLine[0].columnIndex
                    });
                }

                Logger.timeEnd('textLayout', `Page ${i} line grouping`);
                Logger.log('textLayout', `Page ${i} - Total lines detected: ${lines.length}`);
                Logger.log('textLayout', `Page ${i} - Line samples (first 100):`,
                    lines.slice(0, 100).map((line, idx) => ({
                        lineNum: idx,
                        column: line.columnIndex !== undefined ? line.columnIndex : 'N/A',
                        y: line.y.toFixed(2),
                        x: line.minX.toFixed(2),
                        width: (line.maxX - line.minX).toFixed(2),
                        items: line.items.length,
                        text: line.items.map(it => it.text).join(' ').substring(0, 60) + '...'
                    }))
                );

                // Detect large gaps (for images)
                Logger.time('textLayout', `Page ${i} gap detection`);
                const gaps = [];
                for (let k = 0; k < lines.length - 1; k++) {
                    const currentBottom = lines[k].y;
                    const nextTop = lines[k + 1].pdfTop;
                    const gapSize = currentBottom - nextTop;
                    const avgFontSize = (lines[k].avgHeight + lines[k + 1].avgHeight) / 2;

                    if (gapSize > avgFontSize * 3) {
                        gaps.push({ afterIndex: k, gapSize: gapSize });
                        Logger.log('textLayout', `Page ${i} - Large gap detected:`, {
                            afterLine: k,
                            gapSize: gapSize.toFixed(2),
                            threshold: (avgFontSize * 3).toFixed(2)
                        });
                    }
                }
                Logger.log('textLayout', `Page ${i} - Total gaps found: ${gaps.length}`);
                Logger.timeEnd('textLayout', `Page ${i} gap detection`);

                // Detect tables (aligned columns of text with consistent spacing)
                Logger.time('tableFinding', `Page ${i} table detection`);

                const detectTable = (startIdx, endIdx) => {
                    const tableLines = lines.slice(startIdx, endIdx + 1);
                    if (tableLines.length < 2) return null;

                    // Check if lines have multiple distinct X positions (columns)
                    const xGroups = {};
                    tableLines.forEach(line => {
                        line.items.forEach(item => {
                            const xKey = Math.round(item.x / 15) * 15;  // Group by ~15px
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(item);
                        });
                    });

                    const numColumns = Object.keys(xGroups).length;
                    // More strict criteria: need at least 3 rows and 2+ columns
                    // Also check that most rows have items in multiple columns
                    const rowsWithMultiCols = tableLines.filter(line => {
                        const positions = new Set(line.items.map(it => Math.round(it.x / 15) * 15));
                        return positions.size >= 2;
                    }).length;

                    const isConsistent = rowsWithMultiCols >= tableLines.length * 0.7;

                    if (numColumns >= 2 && tableLines.length >= 3 && isConsistent) {
                        Logger.log('tableFinding', `Page ${i} - Table candidate found:`, {
                            startLine: startIdx,
                            endLine: endIdx,
                            rows: tableLines.length,
                            columns: numColumns,
                            consistency: `${((rowsWithMultiCols / tableLines.length) * 100).toFixed(1)}%`
                        });

                        return {
                            isTable: true,
                            startIdx: startIdx,
                            endIdx: endIdx,
                            numColumns: numColumns,
                            columnXs: Object.keys(xGroups).map(Number).sort((a, b) => a - b)
                        };
                    }
                    return null;
                };

                // Identify table regions
                const tableRegions = [];
                let potentialTableStart = null;

                for (let k = 0; k < lines.length; k++) {
                    const line = lines[k];
                    const hasMultipleItems = line.items.length >= 3;
                    const avgItemLength = line.items.reduce((sum, it) => sum + it.text.length, 0) / line.items.length;
                    const isShortLine = avgItemLength < 20;

                    if (hasMultipleItems && isShortLine) {
                        if (potentialTableStart === null) {
                            potentialTableStart = k;
                        }
                    } else {
                        if (potentialTableStart !== null && k - potentialTableStart >= 3) {
                            const table = detectTable(potentialTableStart, k - 1);
                            if (table) {
                                tableRegions.push(table);
                            }
                        }
                        potentialTableStart = null;
                    }
                }

                Logger.log('tableFinding', `Page ${i} - Total tables detected: ${tableRegions.length}`);

                if (tableRegions.length > 0) {
                    Logger.log('tableFinding', `Page ${i} - Table details:`,
                        tableRegions.map(t => ({
                            startLine: t.startIdx,
                            endLine: t.endIdx,
                            rows: t.endIdx - t.startIdx + 1,
                            columns: t.numColumns
                        }))
                    );
                }

                Logger.timeEnd('tableFinding', `Page ${i} table detection`);

                // Build content with images inserted at gaps
                let imageIndex = 0;
                const content = [];

                for (let k = 0; k < lines.length; k++) {
                    content.push({ type: 'line', line: lines[k], lineIndex: k });

                    const gapHere = gaps.find(g => g.afterIndex === k);
                    if (gapHere && imageIndex < imageItems.length) {
                        content.push({ type: 'image', dataUrl: imageItems[imageIndex].dataUrl });
                        imageIndex++;
                    }
                }

                // Add remaining images
                while (imageIndex < imageItems.length) {
                    content.push({ type: 'image', dataUrl: imageItems[imageIndex].dataUrl });
                    imageIndex++;
                }

                // Group lines into blocks (paragraphs, tables, headings)
                Logger.time('paragraphs', `Page ${i} block grouping`);
                const blocks = [];
                let currentParagraph = [];
                let lastLineY = null;

                content.forEach((item, idx) => {
                    if (item.type === 'image') {
                        // Flush current paragraph
                        if (currentParagraph.length > 0) {
                            blocks.push({ type: 'paragraph', lines: currentParagraph });
                            currentParagraph = [];
                        }
                        blocks.push({ type: 'image', dataUrl: item.dataUrl });
                        lastLineY = null;
                    } else if (item.type === 'line') {
                        const line = item.line;
                        const lineIndex = item.lineIndex;

                        // Check if this line is part of a table
                        const inTable = tableRegions.some(t => lineIndex >= t.startIdx && lineIndex <= t.endIdx);

                        if (inTable) {
                            // Flush paragraph and start/continue table
                            if (currentParagraph.length > 0 && currentParagraph[0].type !== 'table') {
                                blocks.push({ type: 'paragraph', lines: currentParagraph });
                                currentParagraph = [];
                            }

                            if (currentParagraph.length === 0 || currentParagraph[0].type !== 'table') {
                                currentParagraph = [{ type: 'table', rows: [] }];
                            }

                            currentParagraph[0].rows.push(line);
                        } else {
                            // Regular text line
                            if (currentParagraph.length > 0 && currentParagraph[0].type === 'table') {
                                blocks.push(currentParagraph[0]);
                                currentParagraph = [];
                            }

                            // Check for paragraph break
                            const maxFontSize = Math.max(...line.items.map(it => it.height));
                            const isHeading = maxFontSize > 15;
                            const largeGap = lastLineY !== null && (lastLineY - line.pdfTop) > line.avgHeight * 2;
                            const mediumGap = lastLineY !== null && (lastLineY - line.pdfTop) > line.avgHeight * 1.3;
                            const anyGap = lastLineY !== null && (lastLineY - line.pdfTop) > line.avgHeight * 0.5;

                            // Check if line is indented (suggesting new paragraph)
                            const isIndented = line.items[0] && line.items[0].x > 100;

                            // Check if previous line ended with sentence-ending punctuation
                            const prevLineEndsParagraph = currentParagraph.length > 0 &&
                                /[.!?]\s*$/.test(currentParagraph[currentParagraph.length - 1].items[currentParagraph[currentParagraph.length - 1].items.length - 1]?.text || '');

                            // Check for font size change between lines (indicates different sections)
                            const prevMaxFontSize = currentParagraph.length > 0 ?
                                Math.max(...currentParagraph[currentParagraph.length - 1].items.map(it => it.height)) : 0;
                            const fontSizeChanged = currentParagraph.length > 0 && Math.abs(maxFontSize - prevMaxFontSize) > 1;

                            // Check if previous line was very short (like an image caption or standalone header)
                            const prevLineText = currentParagraph.length > 0 ?
                                currentParagraph[currentParagraph.length - 1].items.map(it => it.text).join('').trim() : '';
                            const prevLineShort = prevLineText.length < 60 && prevLineText.length > 0;

                            // Check if current line is very short (could be a standalone element)
                            const currentLineText = line.items.map(it => it.text).join('').trim();
                            const currentLineShort = currentLineText.length < 60;

                            // Check if current line ends with punctuation
                            const endsWithPunctuation = /[.!?:;]\s*$/.test(currentLineText);

                            // Detect standalone section headers (short lines that look like titles)
                            const isStandaloneHeader = currentLineShort &&
                                currentLineText.length > 3 &&
                                !endsWithPunctuation &&
                                !/^(The|A|An|In|On|At|From|To|For|By|With)\s/.test(currentLineText) &&
                                currentLineText === currentLineText.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');

                            // Detect page headers/footers (short lines with page numbers, "Part", "Chapter", etc.)
                            const isPageHeader = currentLineShort && (
                                /^(\d+\s*)?(Part|Chapter|Section).*[‚Ä¢|]/.test(currentLineText) ||
                                /^\d+\s+(Part|Chapter|Section)\s+[IVX\d]+/.test(currentLineText) ||
                                (line.items.some(it => /Part|Chapter|Section/i.test(it.text)) &&
                                 line.items.some(it => /^[‚Ä¢|]$/.test(it.text.trim())))
                            );
                            const wasPrevPageHeader = currentParagraph.length > 0 && prevLineShort && (
                                /^(\d+\s*)?(Part|Chapter|Section).*[‚Ä¢|]/.test(prevLineText) ||
                                /^\d+\s+(Part|Chapter|Section)\s+[IVX\d]+/.test(prevLineText) ||
                                (currentParagraph[currentParagraph.length - 1].items.some(it => /Part|Chapter|Section/i.test(it.text)) &&
                                 currentParagraph[currentParagraph.length - 1].items.some(it => /^[‚Ä¢|]$/.test(it.text.trim())))
                            );

                            const isNewParagraph = largeGap ||
                                                  (prevLineEndsParagraph && isIndented) ||
                                                  fontSizeChanged ||
                                                  (mediumGap && prevLineShort) ||
                                                  (anyGap && wasPrevPageHeader) ||
                                                  isPageHeader ||
                                                  isStandaloneHeader;

                            if ((isNewParagraph || isHeading) && currentParagraph.length > 0) {
                                blocks.push({ type: 'paragraph', lines: currentParagraph });
                                currentParagraph = [];
                            }

                            currentParagraph.push(line);
                        }

                        lastLineY = line.y;
                    }
                });

                // Flush remaining paragraph or table
                if (currentParagraph.length > 0) {
                    if (currentParagraph[0].type === 'table') {
                        blocks.push(currentParagraph[0]);
                    } else {
                        blocks.push({ type: 'paragraph', lines: currentParagraph });
                    }
                }

                Logger.timeEnd('paragraphs', `Page ${i} block grouping`);

                const blockSummary = {
                    paragraphs: blocks.filter(b => b.type === 'paragraph').length,
                    tables: blocks.filter(b => b.type === 'table').length,
                    images: blocks.filter(b => b.type === 'image').length,
                    total: blocks.length
                };

                Logger.log('paragraphs', `Page ${i} - Block summary:`, blockSummary);


                // Render blocks
                blocks.forEach(block => {
                    if (block.type === 'image') {
                        pageHtml += `<div style="margin: 1.5em 0; text-align: center;">
                            <img src="${block.dataUrl}" style="max-width: 100%; height: auto; border: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,0.1);" alt="Extracted Image">
                        </div>`;
                    } else if (block.type === 'table') {
                        // Render as table
                        pageHtml += `<div style="margin: 1em 0; overflow-x: auto;">
                            <table style="border-collapse: collapse; width: auto; margin: 0 auto;">`;

                        block.rows.forEach((row, rowIdx) => {
                            pageHtml += `<tr>`;
                            row.items.forEach(item => {
                                const isBold = item.fontName.toLowerCase().includes('bold');
                                const fontSize = Math.round(item.height);
                                const isHeader = rowIdx === 0 || isBold;
                                const tag = isHeader ? 'th' : 'td';
                                const styles = [
                                    `font-size: ${fontSize}px`,
                                    'padding: 6px 12px',
                                    'border: 1px solid #ddd',
                                    'text-align: left'
                                ];
                                if (isBold) styles.push('font-weight: bold');
                                if (isHeader) styles.push('background: #f5f5f5');

                                pageHtml += `<${tag} style="${styles.join('; ')}">${item.text}</${tag}>`;
                            });
                            pageHtml += `</tr>`;
                        });

                        pageHtml += `</table></div>`;
                    } else if (block.type === 'paragraph') {
                        // Get all text items from lines
                        const allItems = block.lines ? block.lines.flatMap(line => line.items) : block.items || [];
                        if (allItems.length === 0) return;

                        const maxFontSize = Math.max(...allItems.map(it => it.height));
                        const isHeading = maxFontSize > 15;
                        const isLargeHeading = maxFontSize > 18;

                        if (isHeading) {
                            // Render as heading
                            let headingText = '';
                            allItems.forEach(item => {
                                const isBold = item.fontName.toLowerCase().includes('bold') ||
                                               item.fontName.toLowerCase().includes('black') ||
                                               item.fontName.toLowerCase().includes('heavy');
                                const isItalic = item.fontName.toLowerCase().includes('italic') ||
                                                 item.fontName.toLowerCase().includes('oblique');

                                const fontSize = Math.round(item.height);
                                let styles = [`font-size: ${fontSize}px`];

                                if (isBold) styles.push('font-weight: bold');
                                if (isItalic) styles.push('font-style: italic');

                                headingText += `<span style="${styles.join('; ')}">${item.text}</span>`;
                            });

                            const headingTag = isLargeHeading ? 'h2' : 'h3';
                            const marginTop = isLargeHeading ? '1.2em' : '1em';
                            pageHtml += `<${headingTag} style="margin: ${marginTop} 0 0.5em 0; line-height: 1.3;">${headingText}</${headingTag}>`;
                        } else {
                            // Render as paragraph with proper line structure
                            pageHtml += `<div style="margin-bottom: 1em; line-height: 1.6; white-space: pre-wrap;">`;

                            block.lines.forEach((line, lineIdx) => {
                                let lineText = '';
                                const lineItems = line.items;

                                // Check if line is a bullet point or list item
                                const firstText = lineItems[0]?.text.trim();
                                const isBullet = /^[\u2022\u2023\u25E6\u2043\u2219\-\*]/.test(firstText) ||
                                                /^[0-9]+[.)]/.test(firstText) ||
                                                /^[a-z][.)]/.test(firstText);

                                // Calculate indentation from left margin
                                const leftX = line.minX;
                                const baseMargin = Math.min(...block.lines.map(l => l.minX));
                                const relativeIndent = leftX - baseMargin;
                                const indentSpaces = Math.round(relativeIndent / 6); // Approximate spaces based on x-offset

                                // Detect definition terms: first item has different font and is short
                                const hasDefinitionTerm = lineItems.length > 1 &&
                                    lineItems[0].fontName !== lineItems[1].fontName &&
                                    lineItems[0].text.trim().length < 50 &&
                                    lineItems[0].text.trim().length > 2;

                                lineItems.forEach((item, idx) => {
                                    const isBold = item.fontName.toLowerCase().includes('bold') ||
                                                   item.fontName.toLowerCase().includes('black') ||
                                                   item.fontName.toLowerCase().includes('heavy');
                                    const isItalic = item.fontName.toLowerCase().includes('italic') ||
                                                     item.fontName.toLowerCase().includes('oblique');

                                    const fontSize = Math.round(item.height);
                                    let styles = [`font-size: ${fontSize}px`];

                                    if (isBold) styles.push('font-weight: bold');
                                    if (isItalic) styles.push('font-style: italic');

                                    const needsSpace = !item.text.endsWith(' ') && idx < lineItems.length - 1;

                                    // If this is a definition term (first item with different font), add line break after it
                                    if (hasDefinitionTerm && idx === 0) {
                                        lineText += `<span style="${styles.join('; ')}">${item.text}</span>\n`;
                                    } else {
                                        lineText += `<span style="${styles.join('; ')}">${item.text}${needsSpace ? ' ' : ''}</span>`;
                                    }
                                });

                                // Add indentation if present
                                const indentation = indentSpaces > 0 ? ' '.repeat(indentSpaces) : '';

                                // Check if this line ends a sentence or should break
                                const endsWithPunctuation = /[.!?:;]\s*$/.test(lineItems[lineItems.length - 1]?.text || '');
                                const nextLineIsBullet = lineIdx < block.lines.length - 1 &&
                                    /^[\u2022\u2023\u25E6\u2043\u2219\-\*]/.test(block.lines[lineIdx + 1]?.items[0]?.text.trim() || '') ||
                                    /^[0-9]+[.)]/.test(block.lines[lineIdx + 1]?.items[0]?.text.trim() || '');

                                // Check if the next line is significantly indented (suggests new paragraph)
                                const nextLineIndented = lineIdx < block.lines.length - 1 &&
                                    (block.lines[lineIdx + 1].minX - baseMargin) > 20;

                                if (isBullet) {
                                    // Render as list item with indentation preserved
                                    pageHtml += `${indentation}${lineText}\n`;
                                } else if (endsWithPunctuation || nextLineIsBullet || nextLineIndented || lineIdx === block.lines.length - 1) {
                                    // Complete sentence or last line - add line break
                                    pageHtml += `${indentation}${lineText}\n`;
                                } else {
                                    // Continuation within same line - no line break, just space
                                    pageHtml += `${lineText} `;
                                }
                            });

                            pageHtml += `</div>`;
                        }
                    }
                });

            pageHtml += `</div>`;

            Logger.timeEnd('performance', `Page ${i} processing`);
            Logger.log('performance', `Page ${i} - Processing complete`);
            Logger.groupEnd('pdfElements');

            return pageHtml;
        }

        async function convertWord(file) {
            Logger.time('performance', 'Word Document Conversion');
            const result = await mammoth.convertToHtml({ arrayBuffer: await file.arrayBuffer() });
            const htmlContent = result.value || '<p>No content found in document</p>';
            const pages = splitHtmlIntoPages(htmlContent);
            Logger.timeEnd('performance', 'Word Document Conversion');
            return { pages, html: htmlContent };
        }

        function splitHtmlIntoPages(html) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            tempDiv.style.cssText = 'position: absolute; visibility: hidden; width: 800px; line-height: 1.6;';
            document.body.appendChild(tempDiv);

            const pages = [], maxPageHeight = 1056;
            let currentPage = '', currentHeight = 0, pageNumber = 1;

            Array.from(tempDiv.children).forEach(element => {
                const testDiv = document.createElement('div');
                testDiv.style.cssText = tempDiv.style.cssText;
                testDiv.appendChild(element.cloneNode(true));
                document.body.appendChild(testDiv);
                const elementHeight = testDiv.offsetHeight;
                document.body.removeChild(testDiv);

                if (currentHeight + elementHeight > maxPageHeight && currentPage.length > 0) {
                    pages.push(`<div style="margin-bottom: 2em;">
                        <div style="font-size: 10px; color: #999; margin-bottom: 1em; border-bottom: 1px solid #ddd; padding-bottom: 0.5em;">Page ${pageNumber}</div>
                        ${currentPage}</div>`);
                    currentPage = '';
                    currentHeight = 0;
                    pageNumber++;
                }

                currentPage += element.outerHTML;
                currentHeight += elementHeight;
            });

            if (currentPage.length > 0) {
                pages.push(`<div style="margin-bottom: 2em;">
                    <div style="font-size: 10px; color: #999; margin-bottom: 1em; border-bottom: 1px solid #ddd; padding-bottom: 0.5em;">Page ${pageNumber}</div>
                    ${currentPage}</div>`);
            }

            document.body.removeChild(tempDiv);
            return pages.length > 0 ? pages : [html];
        }

        window.panel1Api = setupPanel(1);
        window.panel2Api = setupPanel(2);
    </script>
</body>
</html>
